<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[执行储存过程参数最好不要传null]]></title>
    <url>%2F2017%2F07%2F26%2F%E6%89%A7%E8%A1%8C%E5%82%A8%E5%AD%98%E8%BF%87%E7%A8%8B%E5%8F%82%E6%95%B0%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BC%A0null%2F</url>
    <content type="text"><![CDATA[Parameter sniffing在SQL Server中有一个叫做 “Parameter sniffing”的特性。SQL Server在存储过程执行之前都会制定一个执行计划。在上面的例子中，SQL在编译的时候并不知道@thedate的值是多少，所以它在执行执行计划的时候就要进行大量的猜测。假设传递给@thedate的参数大部分都是非空字符串，而FACT表中有40%的thedate字段都是null，那么SQL Server就会选择全表扫描而不是索引扫描来对参数@thedate制定执行计划。全表扫描是在参数为空或为0的时候最好的执行计划。但是全表扫描严重影响了性能。假设你第一次使用了Exec pro_ImAnalysis_daily @thedate=’20080312’那么SQL Server就会使用20080312这个值作为下次参数@thedate的执行计划的参考值，而不会进行全表扫描了，但是如果使用@thedate=null,则下次执行计划就要根据全表扫描进行了。 如何避免Parameter sniffing问题有两种方式能够避免出现“Parameter sniffing”问题： 通过使用declare声明的变量来代替参数：使用set @variable=@thedate的方式，将出现@thedate的sql语句全部用@variable来代替。 将受影响的sql语句隐藏起来，比如： 将受影响的sql语句放到某个子存储过程中，比如我们在@thedate设置成为今天后再调用一个字存储过程将@thedate作为参数传入就可以了。 annnnn 使用动态 sql EXEC(@sql)来执行受影响的sql。 1alert(&quot;123&quot;); 12alert(&apos;Hello World!&apos;); Upstage Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Table of Contents Chapter 1 Chapter 2 Chapter 3]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的事件监听机制]]></title>
    <url>%2F2017%2F07%2F24%2FJS%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[很久以前有个叫Netscape的姑娘，她制订了Javascript的一套事件驱动机制（即事件捕获）后来又有一个叫“IE”的小子，这孩子比较傲气，他认为“凭什么我要依照你的规则走”，于是他又创造了一套自己的规则（事件冒泡）再后来，有个叫W3C的媒婆，想撮合这两个孩子，将他们的特点融合在了一起，这下，事件产生的顺序变成：事件从根节点开始，逐级派送到子节点，若节点绑定了事件动作，则执行动作，然后继续走，这个阶段称为“捕获阶段(Capture)”；执行完捕获阶段后，事件由子节点往根节点派送，若节点绑定了事件动作，则执行动作，然后继续走，这个阶段称为“冒泡阶段(Bubble)”。 善良的Netscape以及其姐妹们都接受了媒婆的建议，采用了新的事件规则，而骄傲固执的IE小子始终按照自己的规则执行。最终使得这成为困扰前端开发人员的兼容性问题之一。那么，怎么绑定事件呢？由于这两派浏览器的差异，其绑定的方法也不一样，其中，遵循标准的浏览器使用W3C定义的addEventListener函数绑定，函数定义如下： function addEventListener(string eventFlag, function eventFunc, [bool useCapture=false])eventFlag : 事件名称，如click、mouseover…eventFunc: 绑定到事件中执行的动作useCapture: 指定是否绑定在捕获阶段，true为是，false为否，默认为true在事件监听流中可以使用event.stopPropagation()来阻止事件继续往下流 IE中使用自有的attachEvent函数绑定时间，函数定义如下：function attachEvent(string eventFlag, function eventFunc)eventFlag: 事件名称，但要加上on，如onclick、onmouseover…eventFunc: 绑定到事件中执行的动作在事件监听流中可以使用window.event.cacenlBubble=false来阻止事件继续往下流总结：addEventListener(string eventFlag, function eventFunc, [bool useCapture=false])，针对ff，chrome，safari浏览器，false指冒泡阶段，默认为true，指捕获阶段。不过一般我们都用false。 attachEvent(string eventFlag, function eventFunc)，针对ie系列、还有opera浏览器，少了事件处理机制的参数，只指定事件类型（别忘了on）和触发哪个函数。 有了这些认知之后，有了大致的思路，对应的代码：if(document.addEventListener){document.addEventListener(‘click’, hideBox, false);在document绑定信息框（竖的那个）隐藏函数（即随便点html页面的哪里关闭展开的信息框，这也是使用document.addEventListener的原因，要帮在文档上）document.getElementById(‘status_hide’).addEventListener(‘click’, showBox, false);在status_hide节点绑定信息框展开(详细的那个)函数并停止事件流（即点击竖的这个，展开详细的那个）document.getElementById(‘status_show’).addEventListener(‘click’, stopEvent, false);因为false确定的是事件冒泡，为了防止点详情的时候，向上冒泡到document，触发document设置的click时hidebox方法，在status_show我们要绑定阻止事件流函数。}这个明白了，针对ie再写个attachEvent的就可以了，当然ie的参数只用2个就可以了，它的时间处理机制就是冒泡不用额外设置。 最后要说说这段函数。var stopEvent = function(event){ e = event || window.event; if(e.stopPropagation){ e.stopPropagation(); }else { e.cancelBubble = true; } };可以确定它的作用是防止前面提到的冒泡，引发不该引发的click事件。可是它呢function(event){e = event || window.event}]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>