<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览器HTTP缓存机制]]></title>
    <url>%2F2017%2F08%2F29%2Fhttp-cache%2F</url>
    <content type="text"><![CDATA[浏览器HTTP缓存机制主要有两种 强缓存（Pragma/Expires/Cache-Control）和 缓存协商（Last-Modified/ETag）。 强缓存所谓强缓存，就是优先命中浏览器的缓存资源，当缓存不符合条件或不存在时，再向服务器发起请求。 http 1.0 协议版本中通过头部字段Pragma/Expires来标识 http 1.1 协议中新增了字段Cache-Control定义缓存过期时间 PragmaPragma是通用首部字段，设置 Pragma:no-cache 用于禁用缓存。 客户端设置如下, 目前只有IE可识别，且不一定会加到请求报文。只对当前页面有效，对页面资源无效 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt; 若响应报文包含Pragma字段，浏览器会对资源标记，后续刷新页面不会命中缓存，而是直接发送请求。 ExpiresExpires是实体首部字段，设置 Expires:[GMT时间值] 用于知会浏览器资源缓存过期时间 客户端设置如下，目前只有IE可识别，且不会加到请求报文。只对当前页面有效，对页面资源无效。如果希望不缓存页面，那么可以把content设为-1或0。 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;mon, 18 apr 2016 14:30:00 GMT&quot; /&gt; 若响应报文包含Expires，字段值返回的是服务端时间。若服务端与客户端时间不同步，这个过期时间就会不准确，导致出错。 如果Expires和Pramga同时出现在报文中，Pragma的优先级更高 Cache-ControlCache-Control是通用首部字段，设置 Cache-Control:[cache-directive] 指令来实现缓存机制。缓存指令是单向的，在响应里设置的指令，在请求中不用包含相同的指令。[cache-directive]有多个可选值，还可以组合使用，且在请求报文和响应报文定义不同，我列出了常见的几种，其它参见MDN文档 请求报文可选值 说明 响应报文可选值 说明 no-cache 不使用缓存，要求向原服务器发起请求 public 任何情况都得缓存资源 no-store 不保存到缓存或临时文件 Private[=field-name] 仅开放给某些用户作缓存,不能做共享缓存 max-age=seconds 告知服务器客户端可接收Age不大于seconds秒的资源 no-cache 不使用缓存，要求向服务器发起 only-if-cached 告知服务器客户端希望优先获取缓存 no-store 不保存到缓存或临时文件 max-stale[=seconds] 告知服务器可接收超过缓存时间的资源 max-age=seconds 告知客户端在seconds秒内，资源不需要再次请求 no-transform 告知服务器客户端希望实体数据没有被转换 must-revalidate 当前资源一定向服务端发去请求验证的，失败返回504 关闭缓存 Cache-Control: no-cache, no-store, must-revalidate 缓存静态资源 Cache-Control:public, max-age=31536000 缓存协商当浏览器缓存过期，向服务器重新发送请求，若服务器资源并未更新时，直接返回304知会客户端使用缓存资源；否则返回更新资源。响应报文通过Last-Modified和ETag来判断缓存资源是否更新。这些做可以提高缓存复用率，加快页面渲染速度。 Last-ModifiedLast-Modified是资源在服务器上的最后修改时间，设置格式 Last-Modified: [GMT时间] 客户端第一次发起请求 -&gt; 服务端 服务端返回数据[加上Last-Modified信息] -&gt; 客户端 -&gt; 客户端标记资源 客户端第二次请求[报文加上标记字段] -&gt; 服务端 服务端[比较修改时间，若一致，直接返回304和响应报头；否则，读取更新资源并返回] -&gt; 客户端 第二次请求报文附加字段有两个： If-Modified-Since:[Last-Modified-value] 该值与服务端一致，返回304 （浏览器以此字段为准） If-Unmodified-Since:[Last-Modified-value] 该值与服务端不一致，返回412 ETagETag是服务器资源生成的唯一标识，设置格式 ETag:[字符串，如md5,guid] 客户端第一次发起请求 -&gt; 服务端 服务端返回数据[加上唯一标识，若是分布式，须保证生成唯一标识的算法一致] -&gt; 客户端 -&gt; 客户端标记ETag 客户端第二次请求[报文加上标记字段] -&gt; 服务端 服务端[比较唯一标识，若一致，直接返回304和响应报头；否则，读取更新资源并返回] -&gt; 客户端 第二次请求报文附加字段有两个：If-None-Match: [ETag-value] 匹配上ETag，直接回送304 （浏览器以此字段为准）If-Match: [ETag-value] 没有匹配上ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412 当If-None-Match与If-Modified-Since一同使用，If-None-Match优先级更高 Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，否则返回更新资源和200 实际应用技巧Chrome 网上有种说法，地址栏输入URL，F5/Ctrl+R(刷新按钮)用自动加上“Cache-Control:max-age=0”，不会命中强缓存，直接发起请求。另外还有一个说法， 不打开DevTool会直接向服务端发起请求，打开则会命中缓存。 这两种说法都是错的。 以上两种情况都会先命中浏览器缓存，我用Chrome60反复测试了。 Chrome从缓存中读取数据，返回的是200 ok from disk cache/200 ok from memory cachefrom memory cache会比from disk cache读取速度更快，两种形式应该是表明缓存读取的方式不同 在DevTool-&gt;network-&gt;勾选disable cahce 或者 shift+F5，都会请求最新内容(304协商缓存、强缓存都无效) 不会检查本地是否有缓存。 请求头信息(request header)不添加If-Modified-Since和If-None-Match字段 查看所有的cache文件可在浏览器输入 chrome://view-http-cache/ 静态资源 静态资源部分，特别是图片资源，需设定一个较长的缓存时间，最好是可以在资源链接上加参数 max-age : http://xxxxx/logo.png?max_age=2592000 服务端在近期修改了该文件的话，因为强缓存客户端将无法获得最新，可将静态资源文件名或参数带上一串md5或时间标记符: https://xxxxxxx/xxxxx.js?e23800c454aa573c0ccb16b52665ac26http://xxxxxx/xxxxx_94e7ca2.js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS练习题]]></title>
    <url>%2F2017%2F08%2F22%2Fexercise%2F</url>
    <content type="text"><![CDATA[整理了一些JS练习题和参考代码，请看下文。 1. 补全parseParm()，使其输出如下结果：{ user: ‘anonymous’, id: [123, 456], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 city: ‘北京’, // 中文 enabled: true, // 未指定值的 key 约定值为 true}url = ‘http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;\ city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled’;parseParam(url); 123456789101112131415161718192021222324function parseParam(url) &#123; var params = &#123;&#125;; var urlArr = (url || &quot;&quot;).split(&quot;?&quot;); if (urlArr.length &lt; 2 || (!urlArr[1])) &#123; return params; &#125; var paramArr = urlArr[1].split(&quot;&amp;&quot;); for (var i = 0; i &lt; paramArr.length; i++) &#123; var pairArr = paramArr[i].split(&apos;=&apos;); var key = pairArr[0]; var value = pairArr.length &gt; 1 ? decodeURI(pairArr[1]) : key == &quot;enabled&quot; ? true : &quot;&quot;; if (params[key] == undefined) &#123; params[key] = value; &#125; else &#123; params[key] = [params[key]]; params[key].push(value); &#125; &#125; return params;&#125; 2. 实现一个最简单的模板引擎:render(‘我是[[name]], 年龄[[age]], 性别[[sex]]’,{ name:’姓名’, age:18}) 1234567// 如果?紧跟在任何量词 * + ? 或 &#123;&#125; 的后面，将会使量词变为非贪婪的（匹配尽量少的字符）// 和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。function render(tpl, data) &#123; return tpl.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g, function (m, m1) &#123; return data[m1]; &#125;)&#125; 3. 将一个任意长的数字变成逗号分割的格式 // 1234.56 =&gt; “1,234.56” , 123456789 =&gt; “123,456,789” parseToMoney(1234.56) // return “1,234.56” 12345678910111213function parseToMoney(num) &#123; num = num || &quot;&quot;; var arr = num.toString().split(&quot;.&quot;); var money = arr[0].replace(/(\d+?)(?=(\d&#123;3&#125;)+$)/g, &quot;$1,&quot;); if (arr.length &gt; 1) &#123; money += &quot;.&quot; + arr[1]; &#125; return money;&#125;parseToMoney(1234567891.34567) 4. 有一个全局变量 a，有一个全局函数 b，实现一个方法bindData，执行后，a的任何赋值都会触发b的执行var a = {x:1};function b(){ console.log(‘a的值发生改变’);}bindData();a.x = 2; // 此时输出 a的值发生改变 1234567891011121314151617181920212223242526272829var a = &#123; x: 1, y: 2 &#125;;function b(key) &#123; console.log(key + &apos;的值发生改变&apos;)&#125;bindData(a, b);function bindData(target, event) &#123; for (var key in target) &#123; if (target.hasOwnProperty(key)) &#123; (function (_target, _key) &#123; var v = _target[_key]; Object.defineProperty(_target, _key, &#123; get: function () &#123; return v; &#125;, set: function (_value) &#123; if (v != _value) &#123; event.call(this, _key) &#125; v = _value; &#125; &#125;) &#125;)(target, key); &#125; &#125;&#125;a.x = 1; 5. 实现一个类，当从某个数字递增或者递减到另外一个数字，并且不管数字如何变化，都可以在指定的时间内完成var AnimateToNum = require(“animate-num”);var numAnim = new AnimateToNum({ animTime:2000, // 每次数字变动持续的时间（ms）， initNum:500, // 初始化的数字 onChange:function(num){ console.log(num);});numAnim.toNum(100); // 从500变化到100，用2000ms的时间，在onChange回调中会一直从500倒数到100 12345678910111213141516171819202122232425262728function AnimateToNum(options) &#123; options = options || &#123;&#125;; this.animTime = options.animTime || 0; this.initNum = options.initNum || 0; this.onChange = options.onChange || function (num) &#123; &#125;;&#125;AnimateToNum.prototype.toNum = function (finalNum) &#123; if (finalNum &gt; this.initNum) &#123; console.log(&quot;参数值不能大于初始值&quot;); return; &#125; if (this.animTime &lt;= 0) &#123; console.log(&quot;设置的animTime必须大于0&quot;); return; &#125; var that = this; var temp = that.initNum setInterval(function () &#123; if (temp &gt; finalNum) &#123; temp--; that.onChange(temp); &#125; &#125;, that.animTime);&#125; 6. 现提供几个读取文件的方法，不借助全局变量实现一个函数，函数可以执行一次后返回一个目录下所有文件中是js后缀的文件列表var readdirSync = function(dir_path){ return [filename] } // 读取一个文件夹下的所有文件夹和文件的路径列表（Array）var isDirectory = function(path) { return true/false; } // 判断一个路径是否是文件夹var existsSync = function(path){ return true/false;} // 判断一个文件/文件夹是否存在var getJSFiles = function(path) {}getJSFiles(‘/code/‘); // return 一个文件列表的数组 1234567891011121314var getJSFiles = function (path) &#123; var result = []; if (existsSync(path)) &#123; if (isDirectory(path)) &#123; readdirSync(path).forEach(function (file) &#123; result = result.concat(getJSFiles(file)) &#125;); &#125; else if (/\.js$/.test(path)) &#123; result.push(path); &#125; &#125; return result;&#125; 7. 请封装一个 CustomFetch 方法，利用原生的 fetch api，但是实现以下几个需求：所有请求默认带上一个 token，值是 xxx请求返回的时候，内部解析内容，并且判断 success 字段是否是 true，如果不是，在 catch 中可以拿到一个Error，message 和 code 是接口返回的对应的内容CustomFetch(“http://api.com/api&quot;).then((data)=&gt;{ console.log(data); // 如果后台返回 true}).catch((e)=&gt;{ console.log(e.message); // 输出 “查询错误”});// 接口的返回模式{ success: false, code: ‘QUERY_ERROR’, data: {}, message: ‘查询错误’} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 定义一个扩展错误类function FetchError(code, message) &#123; this.code = code; this.message = message; this.name = &quot;FetchError&quot;; this.stack = (new Error()).stack;&#125;FetchError.prototype = Object.create(Error.prototype);FetchError.prototype.constructor = FetchError;// 自定义fetch方法function CustomFetch(url) &#123; var myHeaders = new Headers(); myHeaders.append(&quot;token&quot;, &quot;xxx&quot;); myHeaders.append(&quot;Content-Type&quot;, &quot;application/json&quot;); return fetch(url, &#123; method: &apos;GET&apos;, headers: myHeaders, mode: &apos;cors&apos;, cache: &apos;default&apos; &#125;).then(function (response) &#123; if (response.ok) &#123; var res = response.json(); if (res.success) &#123; return res.data; &#125; else &#123; //throw &#123; code: res.code, message: res.message &#125;; throw new FetchError(res.code, res.message); &#125; &#125; else &#123; //throw &#123; code: response.status, message: response.statusText &#125;; throw new FetchError(response.status, response.statusText) &#125; &#125;);&#125;// 定义一个基于Promise的Ajax数据请求方法function getJSON(url, method, data, isAsync) &#123; return new Promise(function (resolve, reject) &#123; var xmlHttp = new XMLHttpRequest(); xmlHttp.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); xmlHttp.responseType = &apos;json&apos;; xmlHttp.onreadystatechange = handler; xmlHttp.open(method || &quot;GET&quot;, url, isAsync == undefined ? true : isAsync); xmlHttp.send(data); function handler() &#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status === 200) &#123; resolve(xmlHttp.response); &#125; else &#123; reject(new Error(xmlHttp.statusText)); &#125; &#125; &#125;);&#125;// 调用示例getJSON(&quot;&quot;).then(function (response) &#123; // success&#125;).then(function (error) &#123; // fail&#125;) 8. 算法题，实现一个函数，可以判断 a 字符串是否被包含在 b 字符串中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 时间复杂度较高的算法function isSubString(a, b) &#123; if (!a || !b) &#123; return false; &#125; for (var i = 0; i &lt; b.length; i++) &#123; var t = i; for (var j = 0; j &lt; a.length; j++) &#123; if (a[j] !== b[t++]) &#123; break; &#125; &#125; if (j == a.length) &#123; return true; &#125; &#125; return false;&#125;isSubString(&quot;abc&quot;, &quot;123abder&quot;);// KMP算法function isSubstrByKMP(a, b, m) &#123; if (!a || !b) &#123; return false; &#125; var i = 0, j = 0; while (i &lt; b.length &amp;&amp; j &lt; a.length) &#123; if (a[j] == b[i]) &#123; j++; i++; &#125; else &#123; if (j == 0) &#123; i++; &#125; else &#123; j = m[j - 1]; &#125; &#125; &#125; if (j == a.length) &#123; return true; &#125; return false;&#125;isSubstrByKMP(&quot;abcdabd&quot;, &quot;bbcabcdababcdabcdabde&quot;, [0, 0, 0, 0, 1, 2, 0]) 9. 下面五段代码分别输出什么？并且什么时候输出什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;// result: 0,1,2,3,4for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000 * i);&#125;// result: 5,5,5,5,5for (var i = 0; i &lt; 5; i++) &#123; (function (i) &#123; setTimeout(function () &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;// result: 0,1,2,3,4for (var i = 0; i &lt; 5; i++) &#123; (function () &#123; setTimeout(function () &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;// result: 5,5,5,5,5for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function (i) &#123; console.log(i); &#125;)(i), i * 1000);&#125;// result: 0,1,2,3,4 10. 将数字转换成中文大写的表示，处理到万级别，例如 12345 =&gt; 一万二千三百四十五function toLowerNum(){}console.log(toLowerNum(12345)); // 输出 一万二千三百四十五console.log(toLowerNum(10001)); // 输出 一万零一console.log(toLowerNum(10011)); // 输出 一万零十一console.log(toLowerNum(10000)); // 输出 一万 (未完待续)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GithubPages+nexT站点搭建]]></title>
    <url>%2F2017%2F07%2F27%2Fhexo-github-nexT%2F</url>
    <content type="text"><![CDATA[写在前面 趁离职期间想整理下这些年积累的东西，决定自己建个站点，为了方便简单选择了Hexo+GitHub Pages。但是做后端开发久了，真心觉得静态站点有点费事。考虑到github免费，那先将就吧，以后还是得自己搞个服务器。这篇先来讲讲搭建时遇到的坑，下一篇讲讲我对Hexo的理解。 Hexo安装关于Hexo安装操作网上有很多，建议直接参考Hexo官网。我贴下几条关键指令： 1234567891011121314151617// 安装Hexo环境npm install hexo-cli -g// 初始化blog站点hexo init blogcd blognpm install// 生成静态文件hexo g// 在本地启动站点，指定端口，请加-p [端口]hexo serverhexo server -p 5000// 发布hexo deploy 利用Github Pages部署站点由于Hexo生成的静态文件，恰好github支持静态文件渲染，github就成了个人博客最好的免费服务器。我在网上查到很多部署方面的文章，基本都是如下说法： 1. 在_config.yml配置deploy参数，前提先安装hexo-deployer-git插件：1234deploy: type: git repo: https://github.com/TerraHuang/terrahuang.github.io.git branch: // 分支这个地方很关键呀，被坑了... 2. 在github上创建新的repository，且以[账号名].github.io命名。将该项目克隆到本地。1git clone https://github.com/TerraHuang/terrahuang.github.io.git 以上步骤都没错，非常正确，不过坑马上就来了。前方高能 大坑一3. 将hexo生成站点的代码发布到master分支，将部署的静态文件代码发布到gh-pages分支，然后在github项目Settings中将Source改为gh-pages。我照做如下： 虽然我的内心很崩溃，但是我还没放弃！！！ 还好Source旁边有个Learn more，用户体验做的不错，点个赞。 点开它，才发现别有洞天呀，网上文章真不能全信~~ 哦，原来[账号名].github.io这种命名只能使用master分支作为站点资源。 另外Github pages还支持其它几种方式，如下： 4. 正确的Github Pages发布方式: 静态站点部署文件应放到master分支 Hexo生成代码放到其它分支，或者新建其它的repository来托管 _config.yml的deploy-&gt;branch须写成master 1234deploy: type: git repo: ... branch: master 在浏览器中请求 https://[账号名].github.io 即为个人站点。 5. Github Pages绑定域名： 在阿里云万网上购买域名 在master分支新建CNAME文件，名称必须全大写，内容为需绑定的域名 在万网域名管理页面新增一条解析，如下： 具体步骤说明，请参考yuan3065的博客：GitHub Pages 绑定来自阿里云的域名 nexT主题及改造毕竟是自己的第一个站点，选用主题也是很谨慎的，在众多炫目的主题中选择了nexT。据说目前是得星最多的一套主题。我看中它的点如下：优势： 样式简洁，文档详细，提供的第三方服务丰富，改造容易 主题色原来的黑色太暗沉，像我心里这么阳光的人，果断换了个明亮的调调。但是nexT并没有提供主题色的更改配置，我用的是笨办法，直接在theme/next/source/css/中修改色值。以后有时间再修改下代码，提取到_config.yml配置中来。 新增第三方服务配置第三方服务比较简单，请参考nexT文档 新增功能如下： 站内搜索：插件hexo-generator-searchdb 文章阅读次数统计：LeanCloud 内容分享：Jiathis 评论系统：disqus（不翻墙无法显示，考虑代理）大坑二特别提醒：注册disqus时，一定要翻墙。如果是利用hosts文件翻墙，请在hosts新增一条[sitename].disqus.com-&gt;xx.xx.xx.xx域名映射，IP地址与disqus.com相同即可。 多图显示为了展示图册效果，尝试显示多图，在网上找到方法如下： 1. 在站点/source下新增pictures/index.md文件。Front-matter如下：123456---title: &quot;图册&quot;type: &quot;picture&quot; //type必须为&apos;picture&apos;layout: postcomments: false--- 2. 内容为多图时，新增标签{\% gp n-n \%}(content){\% endgp \%}。具体如下： 1234&#123;% gp 2-2 %&#125;![](http://octodex.github.com/images/minion.png)![](http://octodex.github.com/images/minion.png)&#123;% endgp %&#125; 然并卵… 前方高能 大坑三居然报错了，为什么会报错，我的内心是拒绝的… 还好我没放弃！！！ 找到{\% gp \%}标签代码：/theme/next/source/script/tags/group-pictures.js 经过多次测试，发现代码错误，修改如下(43-63行)：123456789101112131415161718192021/*** 2-2** □ □ // 此为n-n设值所展示的排列方式，作为设值参考。默认：一行3列，依次排列** @param pictures*/group2Layout2: function (pictures) &#123; return this.getHTML([pictures]); // 将pictures变成二维数组作为实参&#125;,/*** 3-1** □ □ □** @param pictures*/group3Layout1: function (pictures) &#123; return this.getHTML([pictures]); // 将pictures变成二维数组作为实参&#125;, 特别说明：其实只有2-2，3-1的组合会报错，只有两个方法传了一维数组，导致后续报错。 好了，现在不报错了。启动起来，果然可以展示一行两列的图组了。 然并卵… 前方高能怎么不能点击放大？！ 我的内心是崩溃的，但是我没有放弃！！！ 通过与非gp标签图片对比，我发现gp标签渲染时，并没有给图片加&lt;a/&gt;标签，导致fancybox插件并未运行起来。 OK，找到原因了。定位代码: 在/theme/next/source/script/tags/group-pictures.js（824行getColumnHtml方法），做如下修改：1234567891011121314151617181920212223getColumnHTML: function (pictures) &#123; var columns = []; var columnWidth = 100 / pictures.length; var columnStyle = &apos; style=&quot;width: &apos; + columnWidth + &apos;%;&quot;&apos;; for (var i = 0; i &lt; pictures.length; i++) &#123; // 在&lt;img /&gt;元素上加一个父层&lt;a/&gt;,结构如下： // &lt;div class=&quot;group-picture-column&quot; &gt; // &lt;a href=&quot;&quot; class=&quot;fancybox fancybox.image&quot; rel=&quot;group&quot;&gt; // &lt;img /&gt; // &lt;/a&gt; // &lt;/div&gt; var src = pictures[i].match(/src=&quot;[^&quot;]*&quot;/)[0].replace(/(src=)|&quot;/g,&quot;&quot;); var html = &apos;&lt;div class=&quot;group-picture-column&quot; &apos; + columnStyle + &apos;&gt;&apos; + &apos;&lt;a href=&quot;&apos;+ src +&apos;&quot; class=&quot;fancybox fancybox.image&quot; rel=&quot;group&quot;&gt;&apos; + pictures[i] + &apos;&lt;/a&gt;&lt;/div&gt;&apos; columns.push(html); &#125; return columns.join(&apos;&apos;); &#125;&#125;; 这回终于解决了。效果请参考我的图册。 填坑完结。希望我踩过的坑，对大家有所帮助。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
        <tag>github</tag>
        <tag>填坑记</tag>
      </tags>
  </entry>
</search>