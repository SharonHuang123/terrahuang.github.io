<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cordova中JS与Native通信原理]]></title>
    <url>%2F2017%2F09%2F24%2Fcordova%2F</url>
    <content type="text"><![CDATA[上一周参加YY直播的面试，被面试官问到cordova通信原理，结果没答上来。我所知道的只是Cordova依托WebView完成JS与Native交互，但具体的原理还真没深入研究过。这篇文章就来总结下cordova在android平台上是如何实现JS与Native通信的。 Cordova PluginCordova框架中绝大部分原生功能都是通过Cordova Plugin来实现的。关键类是 PluginManager,NativeToJsMessageQueue,CordovaBridge以及CordovaPlugin。原生功能都是通过继承CordovaPlugin来实现，扩展一个原生功能非常简单，只需重载如下几个方法： void initialize(CordovaInterface cordova, CordovaWebView webView) boolean execute(String action, String rawArgs, CallbackContext callbackContext) //存在多态 void onActivityResult(int requestCode, int resultCode, Intent intent) // activity交互 实现过程可参见cordova提供的插件包，如Device,Camera等。然后，我们在config.xml注册下插件名及相应类名，如下：123&lt;feature name=&quot;Camera&quot;&gt; &lt;param name=&quot;android-package&quot; value=&quot;org.apache.cordova.camera.CameraLauncher&quot; /&gt;&lt;/feature&gt; 前端JS调用接口 Cordova.exec(successCallback, failCallback, &#39;Camera&#39;, method, argArr)即可调用到原生功能。 下面我们来了解JS与Native的通信过程, 两个方向：JS调用Native, Native调用JS。 JS调用Native首先，我们看下cordova.js中nativeapiprovider的实现：12var nativeApi = this._cordovaNative || require(&apos;cordova/android/promptbasednativeapi&apos;);var currentApi = nativeApi; nativeApi 有两个来源：_cordovaNative 和 require(‘cordova/android/promptbasednativeapi’)即 prompt1. _cordovaNative WebView通过addJavascriptInterface()暴露出来供前端调用，在SystemWebView（即cordova扩展的webview子类）初始化时注册的。12SystemExposedJsApi exposedJsApi = new SystemExposedJsApi(bridge);webView.addJavascriptInterface(exposedJsApi, &quot;_cordovaNative&quot;); SystemExposedJsApi类实现的exec()方法如下：1234@JavascriptInterfacepublic String exec(int bridgeSecret, String service, String action, String callbackId, String arguments) throws JSONException, IllegalAccessException &#123; return this.bridge.jsExec(bridgeSecret, service, action, callbackId, arguments);&#125; 前端Cordova.exec()方法其实是可通过_cordovaNative.exec()直接调用到SystemExposedJsApi的exec()方法。CordovaBridge执行jsExec()，通过PluginManager, 调用到相应Plugin类的initialize(),execute()等方法，实现原生功能。 2. prompt 在不支持addJavascriptInterface()情况下，Native可拦截window.prompt()消息，通过解析消息来实现插件功能调用。前端cordova对prompt()的实现如下：123456module.exports = &#123; exec: function(bridgeSecret, service, action, callbackId, argsJson) &#123; return prompt(argsJson, &apos;gap:&apos;+JSON.stringify([bridgeSecret, service, action, callbackId])); &#125;, //......&#125;; 而在Native部分，SystemWebView初始化时，通过setWebChromeClient(), 注入SystemWebChromeClient类来实现对prompt消息拦截：1234567891011public boolean onJsPrompt(WebView view, String origin, String message, String defaultValue, final JsPromptResult result) &#123; String handledRet = this.parentEngine.bridge.promptOnJsPrompt(origin, message, defaultValue); if(handledRet != null) &#123; result.confirm(handledRet); &#125; else &#123; //...... &#125; return true;&#125; 同样由CordovaBridge执行promptOnJsPrompt()解析消息后，调用jsExec()，与方式一的调用一致。 以上两种方式，从JS到Native的通信关键有两点： WebView提供的接口addJavascriptInterface() SystemWebChromeClient父类 WebChromeClient 提供的接口onJsPrompt() 归根到底，Cordova并没有在通信机制上做文章，是沿用WebView的底层实现。这个底层实现我们放到最后来分析。 Native调用JSNative中调用JS, 最明显的是WebView提供的loadUrl(), 参数传入以javascript:开头的字符串，即可执行字符串中的JS代码。此外，就是Cordova.exec()中回调函数的执行，即 CallbackContext 如何执行。 1. loadUrl()12webView.loadUrl(&apos;file:///android_asset/www/index.html&apos;)webView.loadUrl(&apos;javascript:alert(&quot;hello world&quot;)&apos;) 2. CallbackContext 当Plugin类的execute()方法执行完以后，参数callbackContext调用success()或error()或sendPluginResult()即可返回结果到前端并执行回调函数。这一过程的调用栈如下： webViewImpl.sendPluginResult(pluginResult, callbackId) // 参数：native执行结果，callbackId nativeToJSMessageQueue.addPluginResult() nativeToJSMessageQueue.equeueMessage() // 返回结果入队 activeBridgeMode.onNativeToJSMessageAvailable() // 按当前桥接模式出队（即EvalBridgeMode） queue.popAndEncodeAsJS() // 出队并按js编码成字符串 webView.evaluateJavascript() // 将结果传入前端并执行回调 前端执行代码：12345678910// 参数：callbackId，native执行结果callbackSuccess: function(callbackId, args) &#123; cordova.callbackFromNative(callbackId, true, args.status, [args.message], args.keepCallback);&#125;,callbackError: function(callbackId, args) &#123; cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);&#125;,// 注：可通过callbackId找到cordova.exec()传入的回调方法。 以上两种方式，Native与JS还是基于WebView的底层实现： webview.loadUrl() webview.evaluateJavascript() Webview底层实现cordova分析了半天，JS与Native的通信其实还是基于WebView, 主要的四个方法如下： addJavascriptInterface() loadUrl() evaluateJavascript() onJSPrompt() 我用最原始的办法，分析调用栈。前三个方法都在WebView类中，且由WebViewProvider提供。通过工厂构造一个WebViewProvider, 需要如下步骤： WebViewFactory.getProvider() // 创建WebViewFactoryProvider实现类 getProviderClass() // 通过反射生成com.android.webview.chromium.WebViewChromiumFactoryProvider类 创建WebViewChromiumFactoryProvider实例 调用createWebView() 创建WebViewChromium（实现WebViewProvider接口）实例 调用栈如下： WebViewChromium 创建AwContents实例，封装AwContents实例方法以对外调用上面提到的三个方法 AwContents 创建ContentViewCore实例，封装ContentViewCore实例方法以对外调用 最后我们看下ContentViewCore类中三个方法的实现：123456789101112131415161718192021222324252627282930/* loadUrl */public void loadUrl(LoadUrlParams params) &#123; if (mNativeContentViewCore == 0) return; nativeLoadUrl(...params); // 参数省略了&#125;private native void nativeLoadUrl(...params);/* addJavaScriptInterface */public void addJavascriptInterface(Object object, String name) &#123; addPossiblyUnsafeJavascriptInterface(object, name, JavascriptInterface.class);&#125;public void addPossiblyUnsafeJavascriptInterface(Object object, String name, Class&lt;? extends Annotation&gt; requiredAnnotation) &#123; if (mNativeContentViewCore != 0 &amp;&amp; object != null) &#123; mJavaScriptInterfaces.put(name, object); nativeAddJavascriptInterface(...); // 参数省略了 &#125;&#125;private native void nativeAddJavascriptInterface(...); //参数省略了/* evaluateJavaScript */public void evaluateJavaScript(String script, JavaScriptCallback callback) throws IllegalStateException &#123; checkIsAlive(); nativeEvaluateJavaScript(mNativeContentViewCore, script, callback);&#125;private native void nativeEvaluateJavaScript(...); //参数省略了 由以上代码可知，ContentViewCore类中出现了JNI, 它允许Java代码和其他语言写的代码进行交互。其实就是与webkit/chromium进行交互，webkit/chromium再与JS交互，实现通信。后面的代码我没有找到，如何从webkit/chromium到JS层交互，目前还没有答案。 之前有看过分析ReactNative中JS与Native通信机制的文章，其实与webview的实现原理大同小异，都是通过Java-JNI-JS这种转换来实现通信。ReactNative可能还要复杂点，毕竟还要解析虚拟DOM。 以上就是我的探讨，有新的发现再来补充。]]></content>
      <categories>
        <category>HybridApp</category>
      </categories>
      <tags>
        <tag>cordova</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转) JavaScript 疲劳终极指南：我们行业的真相]]></title>
    <url>%2F2017%2F09%2F04%2Fforward-1%2F</url>
    <content type="text"><![CDATA[看到这篇文章，很有感触，恰好是我在上一家公司面临的困惑。为了减小支出，几乎不愿做新技术尝试，大多数开发人员都在不停重复。文章说到，测试驱动开发，但是在公司里绝大多数项目没有单元测试代码，测试人员都相当少，集成测试，回归测试，用户测试只是走个程序。移动端开发更甚，为了节约时间，连测试都省了，线上问题层出不穷。我相信其它公司也有这种现象，但究竟怎么做才是支出与收益的平衡呢？使用一种技术是为了解决问题，但是如果有更好的方案呢？ 本文转载自：众成翻译译者：myvin链接：http://www.zcfy.cc/article/3914原文：http://lucasfcosta.com/2017/07/17/The-Ultimate-Guide-to-JavaScript-Fatigue.html 抱怨 JS 疲劳就像是在抱怨人类发明了太多解决问题的工具：从邮件到飞机到宇宙飞船。 上周我在 NebraskaJS 2017 会议上做了一个和这个话题极其类似的演讲，我也收到了许多积极的反馈，所以我就想这个演讲也可以写成一篇文章发表出来，让更多的人知道，并帮助他们应对 JS 疲劳，理解我们行业的真相。这篇文章的目的是希望改变你对软件工程行业的普遍的看法，助你在你可能工作的领域上一臂之力。 激励我写下这篇文章并且彻底改变我生活的一个原因是 Patrick McKenzie 写的这篇很赞的文章，文章名叫《请不要自称程序员和一些职业生涯建议》。强烈推荐你阅读下上面这篇文章。本文的大部分内容都是基于 Patrick 的那篇关于 JavaScript 生态系统的文章的建议，其中也夹杂了最近几年我在科技行业工作的一些想法。 第一个章节可能会有点哲学化，但是我保证绝对值得一读。 我们行业的真相 101就像 Patrick 在 他的文章 里写到的，我们先从一些最基础、最根本的真相说起： 软件是用来解决业务问题的 实事就是这样。软件存在的意义并不是用来取悦我们程序员的，并不是为了让我们写出漂亮代码的，也不是为科技行业创造就业机会的。实际上，软件的存在扼杀了太多的工作岗位，其中也包括我们的，这就是为什么基本工资在未来的几年将会变得更加重要，但是这就完全是另一个话题了。 我这样说很抱歉，但是归根结底原因在于：在软件工程中（其他行业也是如此）只有两样东西至关重要： 支出和收益 支出削减的越多，收益提升的越多，那么你的价值就越大，削减支出、提升收益最通用的一个方法就是用机器代替人工，从长远来看，这种方法是更有效的，而且支出也更少。 你不是被雇佣来写代码的 科技不是目的。没有人关心你使用的是什么编程语言，没有人关心你的团队选择的是什么框架，没有人关心你的数据结构有多么优雅，也没有人关心你的代码写得有多漂亮。人们唯一关心的是：你的软件支出是多少，产生的收益是多少，仅此而已。 写出漂亮的代码对于你的客户而言没有任何卵用。我们之所以要写漂亮的代码，是因为长远来看这样会更高效，能够减少支出，增加收益。 我们努力避免 bug 不是说我们重视正确性，而是我们的客户重视正确性。如果你曾经遇到过一个 bug 成为了一个特性的话，那么你就知道我在说什么了。这个 bug 确实存在，但是我们不会去修复。出现这种情况并不是说我们的目的就是制造 bug，我们的目的是创造价值。但是如果我们的 bug 能够使客户开心，能够提升他们的收益，我们也能达成我们的目标，如此皆大欢喜，何乐而不为呢。 可重复使用的太空火箭、自动驾驶汽车、机器人、AI：这些东西之所以存在，并不是因为我们觉得它们很酷，而是因为在它们的背后有商业利益存在。我并不是说这些东西背后的那群人只在乎金钱，我确定他们也认为这东西很酷，但事实是，如果没有经济利益或者说没有潜在的经济价值，这些东西是不会存在的。 也许我不应该将这一章节取名为“我们行业的真相 101”，也许应该取名为“资本主义真相 101”。 说到我们的目标——减少支出提升收益——我认为作为程序员的我们应该更加关注需求和设计，积极思考，积极参与业务决策，这就是为什么了解我们正在开展的问题领域变得极其重要。之前你有多少次在你的经理或商务人士没有考虑到的某些边缘案例中想到应该发生什么？ 1975 年，Boehm 做过一项研究，研究发现，软件中 64% 的错误都是由设计引起的，只有 36% 的错误是代码错误。另一项叫做 “高阶软件——软件定义方法论” 的研究也显示：在 NASA 的阿波罗计划中，73% 的错误都是设计错误。 设计和需求存在的唯一目的就是定义我们将要解决的问题，而解决问题就能创造收益。 没有了需求或设计，编程就是往一个空的 text 文件里面添加 bug。 Louis Srygley 这个原则同样适用于 JavaScript 生态系统的工具。Babel、webpack、react、Redux、Mocha、Chai、Typescript，所有这些工具之所以存在就是为了解决对应的问题，我们要理解它们要解决的是什么问题，要仔细思考什么时候需要这些工具，否则，我们就会感到 JS 疲劳，因为： 当我们使用我们不需要的工具来解决根本就不存在的问题的时候，JS 疲劳就出现了。 正如 Donald Knuth 曾今说的：“过早优化是万恶之源”。请记着，软件的存在是为了解决相应的业务问题，大部分的软件其实都挺令人厌烦的，既没有多强的扩展性，也没有高性能约束。要专注于解决业务问题，专注于减少支出、提升收益，这才是需要关注的焦点。只有在当你需要优化的时候才去优化，否则，软件可能会增加一些不必要的复杂性，而这些复杂性会增加支出，并且不能产生足够的收益来抵消这些支出。 这就是为什么我认为应该在我们的工作当中应用 测试驱动开发 原则。我说的测试驱动开发并不是说仅仅去做测试。我说的是在问题暴露之前将其扼杀在摇篮里。这才是 TDD 要做的。正如 Kent Beck 说的“TDD 减少了恐惧”，因为它能够指导你的开发节奏，允许你慢慢地逐步解决你的问题，一步一个脚印，一次解决一个问题。当我们要使用新的技术时，这样做同样也会减少恐惧。 一次解决一个问题同时也降低了 分析麻痹，举个栗子，就好比你打开了 Netflix，你本可以看一些视频的，但是却花了三个小时来决定看什么。一次解决一个问题的方式可以缩小我们做决定的范围，缩小了做决定的范围我们的选择就会相对减少，选择减少了我们就降低了分析麻痹。 不知道你有木有想过，如果只有几个可看的电视频道，决定看哪个频道会变得多么简单？如果家里只有几张游戏盘，决定玩儿哪个游戏会变得多么简单？ 那么对于 JavaScript 而言呢？截止到我写这篇文章时，NPM 上有 489,989 个包，第二天将会有差不多 515 个包在上面发布。 我们使用、抱怨的这些包都是有一个历史出发点的的，为了理解我们为什么需要这些包，我们必须理解这个历史出发点：它们是用来解决问题的。 Babel、Dart、CoffeeScript 和其他转义器之所以会出现，是因为我们不仅仅使用 JavaScript 写代码，但是我们又想使其能够在浏览器中正常运行。Babel 甚至能够使我们使用 JavaScript 新版本语法写的代码在旧版本浏览器中运行，因为众所周知，不同版本的 ECMA 规范在各个浏览器中的兼容是一个很大的问题。尽管现在 ECMA 规范已经越来越可靠，但是我们仍然需要 Babel。如果你想了解更多关于 Babel 的相关知识，我强烈推荐你读读 这篇由 Henry Zhu 写的很赞的文章。 像 Webpack 和 Browserify 这样的模块化打包工具也有它们存在的理由。想必你们依然记得，曾几何时，我们使用大量的 script 标签将脚本引入使其能够正常运行。这样做的结果就是污染了全局命名空间，当一个脚本依赖另一个脚本时，很难合理地将它们整合起来。为了解决这个问题，Require.js诞生了，但是它仍然有它自己的问题：它不够简单，语法也会引起其他问题，正如你在这篇文章中看到的。然后 Node.js 借鉴了 CommonJS 的 import，这种 import 是同步的，简单整洁，但是我们仍然需要一种可以在浏览器中运行的方式，这就是为什么我们需要 Webpack 和 Browserify 的原因。 Webpack 确实解决了很多问题，比如可以像处理 JavaScript 依赖那样处理 CSS、图片和许多其他的资源。 前端框架确实有点复杂，但是由于它们的存在，使得我们写代码时减少了同步加载，如此一来，我们就不必担心 DOM 操作，甚至也不用和那些乱七八糟的浏览器 API（JQuery 已经解决了这个问题）直接打交道，众所周知，浏览器的兼容性处理错误百出，而且效率低下。 这就是我们在计算机科学中一直在做的事情。我们使用低级抽象，并在其上构建更多的抽象。我们应该更多考虑的是，我们的软件应该如何运行，而不是怎么让它运行，这样的话，才能更高效。 但是所有这些工具都有一个共同之处：它们之所以存在是因为 web 平台发展太快了。如今任何地方都有 web 技术的存在：web 浏览器，桌面应用，电话应用，甚至手表应用。 这个革命性发展同样也暴露出了我们需要解决的问题。比如，渐进式 web 应用（PWA），它们之所以存在不是因为它们很炫酷，不是因为作为程序员的我们乐于写 PWA。请牢记本文的第一节：PWA 之所以存在，是因为它们创造了商业价值。 通常情况下，标准的制定速度并没有那么快，因此，针对对应的问题我们需要自己寻求解决方法，这就是为什么有一个活跃度高、有创造力的社区是一件很 nice 的事情。我们不是在解决问题，就是在去解决问题的路上。当然，我们也会顺其自然。 适用于我们的工具会更好地成长，获得更多的贡献者，更快地发展，有时一些工具最终将融合来自于其他工具的优秀想法，并且变得比它们更受欢迎。这就是我们演变的进程。 拥有越多的工具，我们就会拥有越多的选择。想必你还记着 UNIX 思想，它主张我们在编程时，一次只做一件事情，而且要将它做到极致。 我们可以清晰的看到这种思想在 JS 测试环境中重现，比如，我们使用 Mocha 跑测试，使用 Chai 做断言，而在 Java 中，JUnit 把这些事情全部包揽了。这就意味着，如果你在使用某一个工具的过程中遇到了问题，并且发现另一个工具更适合我们的话，那么我们就可以直接简单的替换掉之前的工具就可以了，其他工具的优势我们依然能够保留。 UNIX 思想同时主张我们应该去写能够“和谐相处”的程序。这正是我们在做的！比如说 Babel、Webpack 和 React。同时使用它们完全能够正常运行，但是我们并不需要使用一个工具而去依赖另一个工具。比如我们在测试环境中使用 Mocha 和 Chai，那么我们也可以安装 Karma 在多种环境中来跑同样的测试。 如何应对针对正在遭受 JS 疲劳的同学，我的第一个建议是：你要清醒的认识到你并不需要掌握所有东西。有时我们会一次性学习过多的知识——甚至当我们并不需要的时候，这样做只会增加疲劳感。你喜欢的领域你要保持积极的学习动力，可以深入了解，而对于其他的知识，你大可保持慵懒的态度。我这里说的慵懒不是让你懒惰，而是在你需要某些知识的时候再去学习。当你遇到了问题，且需要使用某项知识技能来解决的时候，直接现学就可以了。 另一个重要的建议是：脚踏实地，从头开始。在你使用任何 JavaScript 框架之前，请确保你对原生 JavaScript 学习的已经足够透彻。这是你掌握 JavaScript 并能够将其“玩弄于鼓掌之中”的唯一途径，否则，当你遇到了你之前从来没有见过的问题时，你就不知道该如何下手。学习核心的 web 技术——CSS、HTML5、JavaScript和计算机科学基础，甚至是 HTTP 协议的工作原理——将会有助于你快速掌握任何其他的技术。 但是，请务必不要用力过度。偶尔你要挑战一下自己，亲自动手做一些项目。正如 Sacha Greif 在这篇文章里写到的那样：花费过多的时间学习基础知识就像你要学习游泳时总是在学习流体动力学。学到一定程度以后，你就应该跳到游泳池里去尝试游泳。 同时，请务必不要拘泥于一项技能。我们现在可用的技术其实在过去都早已被发明出来了。当然，它们特性不同，名字不同，但是，本质上它们都是相同的。 如果你看看 NPM 的话，它也不是什么新技术，很早之前就有 Maven Central 和 Ruby Gems 了。 用来转义代码的 Babel，也是借鉴了早期一些非常出名的编译器的原则和理论，比如 GCC。 甚至 JSX 也不是什么新想法。E4X（ECMAScript for XML）10 多年前就存在了。 那么现在你可能会问：“那 Gulp、Grunt 和 NPM 脚本又如何呢？”额，好吧，很遗憾的告诉你，这些问题 GNU Make 在 1976 年都已经解决了。实际上，现在仍然有大量的 JavaScript 工程在使用 GNU Make，比如 Chai.js。但是我们不会那样做，因为我们是喜欢复古的潮人。我们使用 make，因为它解决了我们的问题，正如我们之前讨论过，这就是你的目标所在。 如果你真的想要理解某项技术，想要在面对任何问题时都能够得心应手，那么，请深入了解。成功最关键的一个因素就是好奇心，所以请深入了解你喜欢的技术。尝试自下而上的理解它们，每当你认为某些东西如“魔法”一般时，那么请通过探索代码库来揭开它的神秘面纱。 在我看来，说到学习这块儿，Richard Feinman 的这句名言最适合不过了： 我创造不了的东西，我理解不了 再来看看下面这句，这是 Richard 在同样的一块儿黑板上写下的： 对于已经存在答案的问题要知道如何解决 是不是很赞？ 当 Richard 说这些话的时候，他正在讨论的是关于获取理论结果并如何复现的问题，但是我认为，该原则同样适用于软件工程。能够解决我们的问题的这些工具已经被发明出来了，它们已经存在了，所以我们也应该能够自己来实现它们。 这正是我喜欢 Egghead.io 中一些视频的原因，视频中 Dan Abramov 解释了如何从头开始实现 Redux 中存在的某些功能，或者教你如何构建自己的 JSX 渲染器。 那么我们为什么不去尝试着自己来实现或者去 GitHub 上阅读代码库理解它们的原理来实现这些东西呢？我确定你一定能够发现很多有用的知识。评论和 demo 也许会撒谎，也许会误导，但是代码不会。 另一个我们在这篇文章中谈论的最多的话题是：你不应该超前你自己。遵循 TDD 原则，一次只解决一个问题。你被雇佣是来降低成本提升收益的，你所做的都是为了解决问题，这就是软件存在的意义。 既然我们喜欢拿我们自身的角色和土木工程相关的作对比，那么就让我们快速对比下软件开发和土木工程，就像Sam Newman 在《构建微服》中做的那样。 我们喜欢自称“工程师”或“架构师”，但是这样真的好么？我们一直在为不到一百年前的计算机开发我们所知的计算机软件，而竞技场都存在大约两千年了。 还记得最近一次看到一座桥坍塌是什么时候吗？还记得最近一次你的手机或浏览器奔溃是什么时候吗？ 为了更好的解释，我借用一个我比较喜欢的栗子。 这是美丽惊艳的巴塞罗那。 当我们从这个距离看这座城市的话，它开起来和世界上的其他城市一般无二，但是当我们从上面俯瞰时，巴塞罗那看起来是这个样子的： 正如你看到的，每一个块儿都有着相同的尺寸，所有的块儿都有条不紊的排列着。如果你曾经去过巴塞罗那的话，你一定知道穿越这座城市有多么爽，知道它运行的多么良好。 但是坐在飞机上俯瞰巴塞罗那的人无法预知两百年或者三百年后它会成为什么样子。城市里的人们进进出出，他们要做的是让城市随着时间的流逝有机地成长、适应。他们必须做好应对变化的准备。 同样的事情也发生在软件方面。软件更新迭代很快，会经常需要重构，需求也会频繁的变更，这完全在我们的预期之外。 所以，不要把自己当做软件工程师，要把自己当做城市规划者。让你的软件有机成长，按需适应。兵来将挡，水来土掩，问题来了就去解决，但是要确保一切都有其所在。 在软件领域做这些事情比在城市里做这些事情要容易的多，因为软件是灵活的，土木工程并不是，在软件世界里，我们的“建筑时长”就是编译时长。在巴塞罗那我们不能通过简单地毁掉建筑给新的建筑腾出空地儿，但是在软件世界里我们可以非常简单的实现。我们随时可以推翻重做，随时可以做实验，我们想构建几次就构建几次，时间花费也就那么几秒钟，但是我们思考的时间却比构建的要多得多。我们的工作是纯智力型的。 所以把自己当做城市规划者，让你的软件按需成长、适应。 通过这样做，你就能够更好的抽象，也会知道在什么合适的时间来采用它们。 正如 Sam Koblenski 所说： 抽象只适用于合适的语境，而合适的语境是随着系统的发展而发展的。 有时候我经常会看到这种现象：有些同学在学习一项新技术时会去寻找模板，但是在我看来，当你开始学习的时候，应当避免使用模板。当然，如果你已经有了一定经验，那么模板和生成器还是很有用的。模板剥夺了大部分的控制权，因此你就学不到如何去新建一个工程，你也无法准确理解每个代码片段适合哪里。 当你无法轻轻松松地把事情搞定，当你感受到的都是苦苦的挣扎时，也许是时候另辟蹊径了。我们的宗旨是力争懒惰，你应该为了以后不工作的目标而去工作。如此一来，你就会有更多的自由时间去做其他的事情，从而减低了成本，提升了收益，所以这也是你达成目的的另一条途径。你不应该没头没脑的努力工作，你要更加聪明的工作。 也许有些人也会拥有你现在的烦恼，但是如果没人这样做的话，那么你的机会就到了，你可以找到你自己的解决方法，可以给其他人伸出援助之手。 但是有时候在你没有看到别人做的更优秀之前，你并不会意识到其实你也可以做的更高效。这就是与人交流的重要性。 通过和其他人交流，你可以分享你的经验，为对方的职业生涯提供帮助，也能发现能够提升我们工作流的新工具，而且更重要的是，你能够学到解决问题的方法。这就是我喜欢阅读分享公司解决问题方法的文章的原因。 尤其是在我们的领域里，我们总是认为 Google 和 StackOverflow 能够回答我们的所有问题，但是我们仍然有必要知道我们要问的问题。我确定会有这么一种场景：你遇到了一个你无法解决的问题，因为你无法准确的知道发生了什么事情，所以你自己都不清楚你应该问什么问题。 但是如果我需要用一个建议来总结整篇文章的话，那就是： 解决问题。 软件不是魔法箱，也不是一首诗（很不幸）。它的存在是为了解决问题，提高人们的生活水平。软件的存在是为了让世界向前发展。 年轻人，该你出动解决问题了。 相关/推荐文章 请不要自称程序员和一些职业生涯建议（强烈推荐）Patrick McKenzie 抽象的代价 Sam Koblenski JavaScript 疲劳根源 Calvin French-Owen JavaScript 疲劳 Eric Clemmons JavaScript 疲劳疲劳 - Dr. Axel Rauschmayer JavaScript 疲劳、AMP、和 Paths.js - JS Party Episode #3 构建微服（书籍） Sam Newman 治愈 JavaScript 疲劳计划 保持联系！ 如果你有任何疑惑、想法或者你不同意我的观点的地方，请在下方留言分享或在 twwitter 上联系我。你的任何想法我都乐于倾听。 谢谢阅读！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>forwarding</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储过程避免参数嗅探]]></title>
    <url>%2F2017%2F08%2F30%2Fparameter-sniffing%2F</url>
    <content type="text"><![CDATA[以前写 SQL Server 存储过程的时候，碰到过一个问题。本来是一个很简单的查询，复杂度也不高，参数@date传成null时，查询特别慢。查了下资料，发现SQL Server有一个叫Parameter sniffing的特性。什么是参数嗅探？可以参见这篇文章：参数嗅探ParameterSniffing。 性能影响SQL Server在存储过程执行之前都会制定一个执行计划。SQL在编译的时候并不知道参数@date的值是多少，所以它在执行执行计划的时候就要进行大量的猜测。假设传递给@date的参数大部分都是非空字符串，而FACT表中有40%的date字段都是null，那么SQL Server就会选择全表扫描而不是索引扫描来对参数@date制定执行计划。全表扫描是在参数为空或为0的时候最好的执行计划，但是全表扫描严重影响了性能。 假设你第一次使用了Exec foo_procedure @date=’20080312’ 那么SQL Server就会使用20080312这个值作为下次参数@date的执行计划的参考值，而不会进行全表扫描了，但是如果使用@date=null, 则下次执行计划就要根据全表扫描进行了。 避免方案有两种方式能够避免出现“Parameter sniffing”问题： 通过使用declare声明的变量来代替参数：使用set @variable=@date的方式，将出现@date的sql语句全部用@variable来代替。 将受影响的sql语句隐藏起来，比如： 将受影响的sql语句放到某个子存储过程中 使用动态sql EXEC(@sql) 来执行受影响的sql]]></content>
      <categories>
        <category>sqlserver</category>
      </categories>
      <tags>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动开发H5页面调试方法]]></title>
    <url>%2F2017%2F08%2F30%2Fhtml5-debugging%2F</url>
    <content type="text"><![CDATA[适用范围 在Win OS下，只能调试android设备 Android模拟器调试，真机环境下需在代码中设置WebView属性 WebView.setWebContentsDebuggingEnabled(true) 才能调试软件要求 安装Chrome浏览器，版本32及以上 安装任意一款安卓模拟器，如夜神，genymotion等。 调试步骤更新hosts文件 请前往https://laod.cn/hosts/2017-google-hosts.html 下载最新hosts文件。 更新本地host文件C:\Windows\System32\drivers\etc\hosts，或只添加google相关域名解析。 编辑hosts文件，添加：61.91.161.217 chrome-devtools-frontend.appspot.com61.91.161.217 chrometophone.appspot.com 更新后，重启电脑。 选择要调试的页面打开模拟器，安装应用，打开要调试的H5页面。 运用Chrome进行调试方式一 打开chrome, 在地址栏输入chrome://inspect 在Devices中，勾选Discover USB devices 找到要调试设备的H5页面 点击inspect, 进入调试页 方式二 打开chrome, 按F12打开DevTools面板 点开more, 选择Remote devices, 打开Devices面板 在Devices中点击要调试的模拟器 选择要调试的H5页面，点击inspect, 进入调试页面 注意事项Chrome官方调试指南可参见：https://developers.google.com/web/tools/chrome-devtools/remote-debugging/?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3debugging/?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3（需更新hosts文件才能访问此网页） Chrome调试功能详解调试页面元素样式1.点击“Select”按钮，选中页面元素2.在Styles面板可动态调整选中元素样式 调试js代码1.进入“Sources”面板，选择要调试的js文件2.标记断点，执行断点操作，如图点击“下一步”，即可进行单步调试 查看本地存储数据1.进入“Resources”面板，选择Local Storage，则可查看存放在localStorage中的数值2.选择Web SQL, 选中H5中新建本地数据库，打开相应表，则可查看表中数据 查看日志和错误信息进入“Console”面板，即可查看js运行错误信息，和调用console相关方法打印出的日志信息]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>webapp</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch API]]></title>
    <url>%2F2017%2F08%2F30%2Ffetch%2F</url>
    <content type="text"><![CDATA[fetch API 提供了一个JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源。 fetch()的实质是将XMLHttpRequest结合Promise做了一层封装，返回的是一个Promise对象。另外，fetch()中数据传送是以数据流（stream）的形式进行的。具体请参见：MDN文档 这里贴上一段fetch源码，大家一看就一目了然：12345678910111213141516171819202122232425262728293031323334353637383940414243self.fetch = function(input, init) &#123; return new Promise(function(resolve, reject) &#123; var request = new Request(input, init) var xhr = new XMLHttpRequest() xhr.onload = function() &#123; var options = &#123; status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || &apos;&apos;) &#125; options.url = &apos;responseURL&apos; in xhr ? xhr.responseURL : options.headers.get(&apos;X-Request-URL&apos;) var body = &apos;response&apos; in xhr ? xhr.response : xhr.responseText resolve(new Response(body, options)) &#125; xhr.onerror = function() &#123; reject(new TypeError(&apos;Network request failed&apos;)) &#125; xhr.ontimeout = function() &#123; reject(new TypeError(&apos;Network request failed&apos;)) &#125; xhr.open(request.method, request.url, true) if (request.credentials === &apos;include&apos;) &#123; xhr.withCredentials = true &#125; else if (request.credentials === &apos;omit&apos;) &#123; xhr.withCredentials = false &#125; if (&apos;responseType&apos; in xhr &amp;&amp; support.blob) &#123; xhr.responseType = &apos;blob&apos; &#125; request.headers.forEach(function(value, name) &#123; xhr.setRequestHeader(name, value) &#125;) xhr.send(typeof request._bodyInit === &apos;undefined&apos; ? null : request._bodyInit) &#125;)&#125; 上面的代码涉及到了三个类，由fetch API提供：Request, Headers, Response Request首先，贴一下fetch的基本用法：123456789101112fetch(input /*请求链接 或 Request对象*/, init/*初始参数*/);// 示例：fetch(&apos;https://api.github.com/&apos;, &#123; method: &quot;GET&quot;, headers: new Headers()&#125;).then(function(response)&#123; var data = response.json(); // ...&#125;).catch(function(error)&#123; // ...&#125;) 当参数input传入一个url， input 和 init 则生成一个Request对象。其中参数init有如下可选字段： method 请求的方法，[GET|POST|HEAD|DELETE|PUT] headers 头部字段, 为一个Headers对象 body 请求实体，GET和HEAD请求没有body credentials 是否可以跨域访问cookie [omit|same-origin|include], chrome默认为include mode 请求的模式, [cors|no-cors|same-origin|navigate]。默认值应该为 cors，可跨域请求。 其中在POST请求中，init的body字段的用法如下：1.以字符串形式传入参数, 即 body: ‘a=1&amp;b=2’ 或 body: JSON.stringify({a:1,b:2}) 2.传入以’x-www-form-urlencoded’格式的查询参数，即 const param = new URLSearchParams();param.append(“a”,1);body: param 3.传入表单数据，包括上传文件，即 const param = new FormData(document.querySelector(‘form’));param.append(‘a’,’1’);body: param HeadersHeaders设定字段，与XMLHttpRequest中方法setRequestHeader()设定字段保持一致，基本用法如下：12345678var headers = new Headers(&#123; &apos;Content-Type&apos;: &apos;text/plain&apos;, &apos;Cache-Control&apos;: &apos;max-age=3600&apos;&#125;);headers.append(&quot;Accept&quot;, &quot;application/json&quot;);headers.set(&apos;X-Custom-Header&apos;,&apos;ProcessThisImmediately&apos;);headers.get(&apos;Accept&apos;); ResponseResponse对象为数据流处理提供了5个方法，如下： .text()：返回字符串 .json()：返回一个JSON对象 .formData()：返回一个FormData对象 .blob()：返回一个blob对象 .arrayBuffer()：返回一个二进制数组但由于body属性是一个stream对象，数据只能单向传送一次，若要多次读取，需要使用clone()方法。 Response的常用属性如下： status：整数值，表示状态码（比如200） statusText：字符串，表示状态信息，默认是“OK” ok：布尔值，表示状态码是否在200-299的范围内 headers：Headers对象，表示HTTP回应的头信息 url：字符串，表示HTTP请求的网址 type：字符串，合法的值有五个basic、cors、default、error、opaque。basic表示正常的同域请求；cors表示CORS机制的跨域请求；error表示网络出错，无法取得信息，status属性为0，headers属性为空，并且导致fetch函数返回Promise对象被拒绝；opaque表示非CORS机制的跨域请求，受到严格限制。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form表单提交常见问题]]></title>
    <url>%2F2017%2F08%2F30%2Fform%2F</url>
    <content type="text"><![CDATA[form表单提交是一个很基础的问题，但是仔细研究下还是挺有意思的。下面，先贴一段html代码，作为讨论的前提：12345678910111213141516&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input placeholder=&quot;密码&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;头像&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; /&gt; &lt;/div&gt; &lt;input id=&quot;save&quot; type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;button&gt;button提交&lt;/button&gt;&lt;/form&gt; 1.submit事件，如何触发，与click事件的发生顺序是怎样？在form表单中按下Enter键或页面按钮，触发submit事件的前提有两种情况： 只有一个输入框（可以没有提交按钮) 至少有一个提交按钮, &lt;input type=&quot;submit&quot;&gt; 和 &lt;button&gt; 都可以看成是提交按钮 若有多个提交按钮，enter键将触发第一个提交按钮事件当提交按钮绑定click事件，先执行click事件，再执行提交事件；要阻止submit事件，在click事件中加上e.preventDefault() 2.提交前如何先做前端数据验证，再提交后台？方案有很多，列举如下： 不使用提交按钮，绑定click事件，先做验证，再通过ajax提交数据 使用提交按钮，绑定click事件，先做验证，不通过则调用e.preventDefault()阻止提交 使用提交按钮，绑定onsubmit事件，先做验证，不通过返回false阻止提交 3.表单文件如何上传？方案有很多，列举如下： 使用提交按钮， 在form标签中，加入 enctype=&quot;multipart/form-data&quot; 不使用提交按钮，通过 new FormData() 收集表单数据，通过ajax提交]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax跨域问题]]></title>
    <url>%2F2017%2F08%2F30%2Fcors%2F</url>
    <content type="text"><![CDATA[Ajax跨域问题是老生常谈了，作Web开发包括WebApp经常碰到，索性一次性写清楚。 首先，跨域问题的产生是源于浏览器的 同源政策 ，目的是保证用户信息安全，防止网站窃取数据。在非同源的情况下，有以下限制： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获取 AJAX 请求不能发送 这里主要讲下如何解决AJAX请求不能发送的问题。解决方案有如下三种： JSONP CORS WebSocket JSONPJSONP的原理就是往页面动态插入 &lt;script&gt; 标签，向服务器请求JSON数据，其返回的数据会传入回调函数，js代码示例如下：12345678910window.onload = function () &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = &apos;http://example.com/ip?callback=foo&apos;; document.body.appendChild(script);&#125;function foo(data)&#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125; 因为通过 &lt;script&gt; 标签发出请求，所以JSONP只支持GET请求。 CORSCORS（Cross-origin resource sharing）：跨域资源共享，是一个w3c标准，允许浏览器向跨源服务器发起Ajax请求。CORS需要浏览器和服务器同时支持，主流浏览器都支持该功能，但IE要在IE10及以上。 CORS请求分为两种：简单请求和非简单请求。详情请见：跨域资源共享 CORS 详解 简单请求简单请求满足以下条件： 请求方法必须是：HEAD,GET,POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type (只限于application/x-www-form-urlencoded、multipart/form-data、text/plain) 处理简单请求时，浏览器直接在头部新增字段 origin: [域名]如果origin字段值在服务器指定域名内，响应头部会新增如下字段;如若没有，则说明请求存在跨源问题，会抛出一个错误，但可能状态码仍然返回200。 Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: Content-Type 非简单请求非简单请求，是指比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。此类cors请求会有两个步骤： 发起预检请求，头部信息如下： 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 若Origin字段在服务器指定域名内，则响应头部信息会新增 Access-Control-Allow-Origin,Access-Control-Allow-Methods,Access-Control-Allow-Headers三个字段(如下)；若无，则会抛出错误。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 预检通过后，浏览器会发出正式请求，和简单请求的过程一样。 了解CORS的内部机制后，要想解决跨域就显而易见了。只需在服务端返回时，在响应头部增加如下字段： Access-Control-Allow-Origin: [http://xxxxx|*] 允许跨源访问域名 或者 * （表明任何源都可以）Access-Control-Allow-Methods：[GET,POST,PUT,DELETE] 允许跨源访问方式Access-Control-Allow-Headers: [头部字段名] 允许额外发送的头信息字段 在ASP.NET中可以在Web.config的 &lt;system.webServer&gt; 节点内新增如下配置：1234567&lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=&quot;Access-Control-Allow-Origin&quot; value=&quot;*&quot; /&gt; &lt;add name=&quot;Access-Control-Allow-Headers&quot; value=&quot;Content-Type&quot; /&gt; &lt;add name=&quot;Access-Control-Allow-Methods&quot; value=&quot;GET, POST, PUT, DELETE, OPTIONS&quot; /&gt; &lt;/customHeaders&gt;&lt;/httpProtocol&gt; WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 WebSocket请求的头信息如下, 服务器可通过 origin 判断当前域名是否在白名单中。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 如验证通过，响应头部如下：12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器HTTP缓存机制]]></title>
    <url>%2F2017%2F08%2F29%2Fhttp-cache%2F</url>
    <content type="text"><![CDATA[浏览器HTTP缓存机制主要有两种 强缓存（Pragma/Expires/Cache-Control）和 缓存协商（Last-Modified/ETag）。 强缓存所谓强缓存，就是优先命中浏览器的缓存资源，当缓存不符合条件或不存在时，再向服务器发起请求。 http 1.0 协议版本中通过头部字段Pragma/Expires来标识 http 1.1 协议中新增了字段Cache-Control定义缓存过期时间 PragmaPragma是通用首部字段，设置 Pragma:no-cache 用于禁用缓存。 1.客户端设置如下, 目前只有IE可识别，且不一定会加到请求报文。只对当前页面有效，对页面资源无效 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt; 2.若响应报文包含Pragma字段，浏览器会对资源标记，后续刷新页面不会命中缓存，而是直接发送请求。 ExpiresExpires是实体首部字段，设置 Expires:[GMT时间值] 用于知会浏览器资源缓存过期时间 1.客户端设置如下，目前只有IE可识别，且不会加到请求报文。只对当前页面有效，对页面资源无效。如果希望不缓存页面，那么可以把content设为-1或0。1&lt;meta http-equiv=&quot;expires&quot; content=&quot;mon, 18 apr 2016 14:30:00 GMT&quot; /&gt; 2.若响应报文包含Expires，字段值返回的是服务端时间。若服务端与客户端时间不同步，这个过期时间就会不准确，导致出错。 如果Expires和Pramga同时出现在报文中，Pragma的优先级更高 Cache-ControlCache-Control是通用首部字段，设置 Cache-Control:[cache-directive] 指令来实现缓存机制。缓存指令是单向的，在响应里设置的指令，在请求中不用包含相同的指令。[cache-directive]有多个可选值，还可以组合使用，且在请求报文和响应报文定义不同，我列出了常见的几种，其它参见MDN文档 请求报文可选值 说明 响应报文可选值 说明 no-cache 不使用缓存，要求向原服务器发起请求 public 任何情况都得缓存资源 no-store 不保存到缓存或临时文件 Private[=field-name] 仅开放给某些用户作缓存,不能做共享缓存 max-age=seconds 告知服务器客户端可接收Age不大于seconds秒的资源 no-cache 不使用缓存，要求向服务器发起 only-if-cached 告知服务器客户端希望优先获取缓存 no-store 不保存到缓存或临时文件 max-stale[=seconds] 告知服务器可接收超过缓存时间的资源 max-age=seconds 告知客户端在seconds秒内，资源不需要再次请求 no-transform 告知服务器客户端希望实体数据没有被转换 must-revalidate 当前资源一定向服务端发去请求验证的，失败返回504 示例 1.关闭缓存Cache-Control: no-cache, no-store, must-revalidate2.缓存静态资源Cache-Control:public, max-age=31536000 缓存协商当浏览器缓存过期，向服务器重新发送请求，若服务器资源并未更新时，直接返回304知会客户端使用缓存资源；否则返回更新资源。响应报文通过Last-Modified和ETag来判断缓存资源是否更新。这些做可以提高缓存复用率，加快页面渲染速度。 Last-ModifiedLast-Modified是资源在服务器上的最后修改时间，设置格式 Last-Modified: [GMT时间] 客户端第一次发起请求 -&gt; 服务端 服务端返回数据 [ 加上Last-Modified信息 ] -&gt; 客户端 -&gt; 客户端标记资源 客户端第二次请求 [ 报文加上标记字段 ] -&gt; 服务端 服务端 [ 比较修改时间，若一致，直接返回304和响应报头；否则，读取更新资源并返回 ] -&gt; 客户端 第二次请求报文附加字段有两个：If-Modified-Since: Last-Modified-value 该值与服务端一致，返回304 （浏览器以此字段为准）If-Unmodified-Since:Last-Modified-value 该值与服务端不一致，返回412 ETagETag是服务器资源生成的唯一标识，设置格式 ETag:[字符串，如md5,guid] 客户端第一次发起请求 -&gt; 服务端 服务端返回数据 [ 加上唯一标识，若是分布式，须保证生成唯一标识的算法一致 ] -&gt; 客户端 -&gt; 客户端标记ETag 客户端第二次请求 [ 报文加上标记字段 ] -&gt; 服务端 服务端 [ 比较唯一标识，若一致，直接返回304和响应报头；否则，读取更新资源并返回 ] -&gt; 客户端 第二次请求报文附加字段有两个：If-None-Match: ETag-value 匹配上ETag，直接回送304 （浏览器以此字段为准）If-Match: ETag-value 没有匹配上ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412 当If-None-Match与If-Modified-Since一同使用，If-None-Match优先级更高Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，否则返回更新资源和200 实际应用技巧Chrome1.网上有种说法，地址栏输入URL，F5/Ctrl+R(刷新按钮)用自动加上“Cache-Control:max-age=0”，不会命中强缓存，直接发起请求。 另外还有一个说法， 不打开DevTool会直接向服务端发起请求，打开则会命中缓存。 这两种说法都是错的。 以上两种情况都会先命中浏览器缓存，我用Chrome60反复测试了。 2.Chrome从缓存中读取数据，返回的是200 ok from disk cache \ 200 ok from memory cache。from memory cache会比from disk cache读取速度更快，两种形式应该是表明缓存读取的方式不同 3.在DevTool-&gt;network-&gt;勾选disable cahce 或者 shift+F5，都会请求最新内容(304协商缓存、强缓存都无效) 不会检查本地是否有缓存。 请求头信息(request header)不添加If-Modified-Since和If-None-Match字段 4.查看所有的cache文件可在浏览器输入 chrome://view-http-cache/ 静态资源1.静态资源部分，特别是图片资源，需设定一个较长的缓存时间，最好是可以在资源链接上加参数 max-age : http://xxxxx/logo.png?max_age=2592000 2.服务端在近期修改了该文件的话，因为强缓存客户端将无法获得最新，可将静态资源文件名或参数带上一串md5或时间标记符: https://xxxxxxx/xxxxx.js?e23800c454aa573c0ccb16b52665ac26http://xxxxxx/xxxxx_94e7ca2.js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS练习题]]></title>
    <url>%2F2017%2F08%2F22%2Fexercise%2F</url>
    <content type="text"><![CDATA[整理了一些JS练习题和参考代码，请看下文。 1. 补全parseParm()，使其输出如下结果：{ user: ‘anonymous’, id: [123, 456], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 city: ‘北京’, // 中文 enabled: true, // 未指定值的 key 约定值为 true}url = ‘http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;\ city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled’;parseParam(url); 123456789101112131415161718192021222324function parseParam(url) &#123; var params = &#123;&#125;; var urlArr = (url || &quot;&quot;).split(&quot;?&quot;); if (urlArr.length &lt; 2 || (!urlArr[1])) &#123; return params; &#125; var paramArr = urlArr[1].split(&quot;&amp;&quot;); for (var i = 0; i &lt; paramArr.length; i++) &#123; var pairArr = paramArr[i].split(&apos;=&apos;); var key = pairArr[0]; var value = pairArr.length &gt; 1 ? decodeURI(pairArr[1]) : key == &quot;enabled&quot; ? true : &quot;&quot;; if (params[key] == undefined) &#123; params[key] = value; &#125; else &#123; params[key] = [params[key]]; params[key].push(value); &#125; &#125; return params;&#125; 2. 实现一个最简单的模板引擎:render(‘我是[[name]], 年龄[[age]], 性别[[sex]]’,{ name:’姓名’, age:18}) 1234567// 如果?紧跟在任何量词 * + ? 或 &#123;&#125; 的后面，将会使量词变为非贪婪的（匹配尽量少的字符）// 和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。function render(tpl, data) &#123; return tpl.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g, function (m, m1) &#123; return data[m1]; &#125;)&#125; 3. 将一个任意长的数字变成逗号分割的格式 // 1234.56 =&gt; “1,234.56” , 123456789 =&gt; “123,456,789” parseToMoney(1234.56) // return “1,234.56” 12345678910111213function parseToMoney(num) &#123; num = num || &quot;&quot;; var arr = num.toString().split(&quot;.&quot;); var money = arr[0].replace(/(\d+?)(?=(\d&#123;3&#125;)+$)/g, &quot;$1,&quot;); if (arr.length &gt; 1) &#123; money += &quot;.&quot; + arr[1]; &#125; return money;&#125;parseToMoney(1234567891.34567) 4. 有一个全局变量 a，有一个全局函数 b，实现一个方法bindData，执行后，a的任何赋值都会触发b的执行var a = {x:1};function b(){ console.log(‘a的值发生改变’);}bindData();a.x = 2; // 此时输出 a的值发生改变 1234567891011121314151617181920212223242526272829var a = &#123; x: 1, y: 2 &#125;;function b(key) &#123; console.log(key + &apos;的值发生改变&apos;)&#125;bindData(a, b);function bindData(target, event) &#123; for (var key in target) &#123; if (target.hasOwnProperty(key)) &#123; (function (_target, _key) &#123; var v = _target[_key]; Object.defineProperty(_target, _key, &#123; get: function () &#123; return v; &#125;, set: function (_value) &#123; if (v != _value) &#123; event.call(this, _key) &#125; v = _value; &#125; &#125;) &#125;)(target, key); &#125; &#125;&#125;a.x = 1; 5. 实现一个类，当从某个数字递增或者递减到另外一个数字，并且不管数字如何变化，都可以在指定的时间内完成var AnimateToNum = require(“animate-num”);var numAnim = new AnimateToNum({ animTime:2000, // 每次数字变动持续的时间（ms）， initNum:500, // 初始化的数字 onChange:function(num){ console.log(num);});numAnim.toNum(100); // 从500变化到100，用2000ms的时间，在onChange回调中会一直从500倒数到100 12345678910111213141516171819202122232425262728function AnimateToNum(options) &#123; options = options || &#123;&#125;; this.animTime = options.animTime || 0; this.initNum = options.initNum || 0; this.onChange = options.onChange || function (num) &#123; &#125;;&#125;AnimateToNum.prototype.toNum = function (finalNum) &#123; if (finalNum &gt; this.initNum) &#123; console.log(&quot;参数值不能大于初始值&quot;); return; &#125; if (this.animTime &lt;= 0) &#123; console.log(&quot;设置的animTime必须大于0&quot;); return; &#125; var that = this; var temp = that.initNum setInterval(function () &#123; if (temp &gt; finalNum) &#123; temp--; that.onChange(temp); &#125; &#125;, that.animTime);&#125; 6. 现提供几个读取文件的方法，不借助全局变量实现一个函数，函数可以执行一次后返回一个目录下所有文件中是js后缀的文件列表var readdirSync = function(dir_path){ return [filename] } // 读取一个文件夹下的所有文件夹和文件的路径列表（Array）var isDirectory = function(path) { return true/false; } // 判断一个路径是否是文件夹var existsSync = function(path){ return true/false;} // 判断一个文件/文件夹是否存在var getJSFiles = function(path) {}getJSFiles(‘/code/‘); // return 一个文件列表的数组 1234567891011121314var getJSFiles = function (path) &#123; var result = []; if (existsSync(path)) &#123; if (isDirectory(path)) &#123; readdirSync(path).forEach(function (file) &#123; result = result.concat(getJSFiles(file)) &#125;); &#125; else if (/\.js$/.test(path)) &#123; result.push(path); &#125; &#125; return result;&#125; 7. 请封装一个 CustomFetch 方法，利用原生的 fetch api，但是实现以下几个需求：所有请求默认带上一个 token，值是 xxx请求返回的时候，内部解析内容，并且判断 success 字段是否是 true，如果不是，在 catch 中可以拿到一个Error，message 和 code 是接口返回的对应的内容CustomFetch(“http://api.com/api&quot;).then((data)=&gt;{ console.log(data); // 如果后台返回 true}).catch((e)=&gt;{ console.log(e.message); // 输出 “查询错误”});// 接口的返回模式{ success: false, code: ‘QUERY_ERROR’, data: {}, message: ‘查询错误’} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 定义一个扩展错误类function FetchError(code, message) &#123; this.code = code; this.message = message; this.name = &quot;FetchError&quot;; this.stack = (new Error()).stack;&#125;FetchError.prototype = Object.create(Error.prototype);FetchError.prototype.constructor = FetchError;// 自定义fetch方法function CustomFetch(url) &#123; var myHeaders = new Headers(); myHeaders.append(&quot;token&quot;, &quot;xxx&quot;); myHeaders.append(&quot;Content-Type&quot;, &quot;application/json&quot;); return fetch(url, &#123; method: &apos;GET&apos;, headers: myHeaders, mode: &apos;cors&apos;, cache: &apos;default&apos; &#125;).then(function (response) &#123; if (response.ok) &#123; var res = response.json(); if (res.success) &#123; return res.data; &#125; else &#123; //throw &#123; code: res.code, message: res.message &#125;; throw new FetchError(res.code, res.message); &#125; &#125; else &#123; //throw &#123; code: response.status, message: response.statusText &#125;; throw new FetchError(response.status, response.statusText) &#125; &#125;);&#125;// 定义一个基于Promise的Ajax数据请求方法function getJSON(url, method, data, isAsync) &#123; return new Promise(function (resolve, reject) &#123; var xmlHttp = new XMLHttpRequest(); xmlHttp.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); xmlHttp.responseType = &apos;json&apos;; xmlHttp.onreadystatechange = handler; xmlHttp.open(method || &quot;GET&quot;, url, isAsync == undefined ? true : isAsync); xmlHttp.send(data); function handler() &#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status === 200) &#123; resolve(xmlHttp.response); &#125; else &#123; reject(new Error(xmlHttp.statusText)); &#125; &#125; &#125;);&#125;// 调用示例getJSON(&quot;&quot;).then(function (response) &#123; // success&#125;).then(function (error) &#123; // fail&#125;) 8. 算法题，实现一个函数，可以判断 a 字符串是否被包含在 b 字符串中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 时间复杂度较高的算法function isSubString(a, b) &#123; if (!a || !b) &#123; return false; &#125; for (var i = 0; i &lt; b.length; i++) &#123; var t = i; for (var j = 0; j &lt; a.length; j++) &#123; if (a[j] !== b[t++]) &#123; break; &#125; &#125; if (j == a.length) &#123; return true; &#125; &#125; return false;&#125;isSubString(&quot;abc&quot;, &quot;123abder&quot;);// KMP算法function isSubstrByKMP(a, b, m) &#123; if (!a || !b) &#123; return false; &#125; var i = 0, j = 0; while (i &lt; b.length &amp;&amp; j &lt; a.length) &#123; if (a[j] == b[i]) &#123; j++; i++; &#125; else &#123; if (j == 0) &#123; i++; &#125; else &#123; j = m[j - 1]; &#125; &#125; &#125; if (j == a.length) &#123; return true; &#125; return false;&#125;isSubstrByKMP(&quot;abcdabd&quot;, &quot;bbcabcdababcdabcdabde&quot;, [0, 0, 0, 0, 1, 2, 0]) 9. 下面五段代码分别输出什么？并且什么时候输出什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;// result: 0,1,2,3,4for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000 * i);&#125;// result: 5,5,5,5,5for (var i = 0; i &lt; 5; i++) &#123; (function (i) &#123; setTimeout(function () &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;// result: 0,1,2,3,4for (var i = 0; i &lt; 5; i++) &#123; (function () &#123; setTimeout(function () &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;// result: 5,5,5,5,5for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function (i) &#123; console.log(i); &#125;)(i), i * 1000);&#125;// result: 0,1,2,3,4 10. 将数字转换成中文大写的表示，处理到万级别，例如 12345 =&gt; 一万二千三百四十五function toLowerNum(){}console.log(toLowerNum(12345)); // 输出 一万二千三百四十五console.log(toLowerNum(10001)); // 输出 一万零一console.log(toLowerNum(10011)); // 输出 一万零十一console.log(toLowerNum(10000)); // 输出 一万 (未完待续)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GithubPages+nexT站点搭建]]></title>
    <url>%2F2017%2F07%2F27%2Fhexo-github-nexT%2F</url>
    <content type="text"><![CDATA[写在前面 趁离职期间想整理下这些年积累的东西，决定自己建个站点，为了方便简单选择了Hexo+GitHub Pages。但是做后端开发久了，真心觉得静态站点有点费事。考虑到github免费，那先将就吧，以后还是得自己搞个服务器。这篇先来讲讲搭建时遇到的坑，下一篇讲讲我对Hexo的理解。 Hexo安装关于Hexo安装操作网上有很多，建议直接参考Hexo官网。我贴下几条关键指令： 1234567891011121314151617// 安装Hexo环境npm install hexo-cli -g// 初始化blog站点hexo init blogcd blognpm install// 生成静态文件hexo g// 在本地启动站点，指定端口，请加-p [端口]hexo serverhexo server -p 5000// 发布hexo deploy 利用Github Pages部署站点由于Hexo生成的静态文件，恰好github支持静态文件渲染，github就成了个人博客最好的免费服务器。我在网上查到很多部署方面的文章，基本都是如下说法： 1. 在_config.yml配置deploy参数，前提先安装hexo-deployer-git插件：1234deploy: type: git repo: https://github.com/TerraHuang/terrahuang.github.io.git branch: // 分支这个地方很关键呀，被坑了... 2. 在github上创建新的repository，且以[账号名].github.io命名。将该项目克隆到本地。1git clone https://github.com/TerraHuang/terrahuang.github.io.git 以上步骤都没错，非常正确，不过坑马上就来了。前方高能 大坑一3. 将hexo生成站点的代码发布到master分支，将部署的静态文件代码发布到gh-pages分支，然后在github项目Settings中将Source改为gh-pages。我照做如下： 虽然我的内心很崩溃，但是我还没放弃！！！ 还好Source旁边有个Learn more，用户体验做的不错，点个赞。 点开它，才发现别有洞天呀，网上文章真不能全信~~ 哦，原来[账号名].github.io这种命名只能使用master分支作为站点资源。 另外Github pages还支持其它几种方式，如下： 4. 正确的Github Pages发布方式: 静态站点部署文件应放到master分支 Hexo生成代码放到其它分支，或者新建其它的repository来托管 _config.yml的deploy-&gt;branch须写成master 1234deploy: type: git repo: ... branch: master 在浏览器中请求 https://[账号名].github.io 即为个人站点。 5. Github Pages绑定域名： 在阿里云万网上购买域名 在master分支新建CNAME文件，名称必须全大写，内容为需绑定的域名 在万网域名管理页面新增一条解析，如下： 具体步骤说明，请参考yuan3065的博客：GitHub Pages 绑定来自阿里云的域名 nexT主题及改造毕竟是自己的第一个站点，选用主题也是很谨慎的，在众多炫目的主题中选择了nexT。据说目前是得星最多的一套主题。我看中它的点如下：优势： 样式简洁，文档详细，提供的第三方服务丰富，改造容易 主题色原来的黑色太暗沉，像我心里这么阳光的人，果断换了个明亮的调调。但是nexT并没有提供主题色的更改配置，我用的是笨办法，直接在theme/next/source/css/中修改色值。以后有时间再修改下代码，提取到_config.yml配置中来。 新增第三方服务配置第三方服务比较简单，请参考nexT文档 新增功能如下： 站内搜索：插件hexo-generator-searchdb 文章阅读次数统计：LeanCloud 内容分享：Jiathis 评论系统：disqus（不翻墙无法显示，考虑代理）大坑二特别提醒：注册disqus时，一定要翻墙。如果是利用hosts文件翻墙，请在hosts新增一条[sitename].disqus.com-&gt;xx.xx.xx.xx域名映射，IP地址与disqus.com相同即可。 多图显示为了展示图册效果，尝试显示多图，在网上找到方法如下： 1. 在站点/source下新增pictures/index.md文件。Front-matter如下：123456---title: &quot;图册&quot;type: &quot;picture&quot; //type必须为&apos;picture&apos;layout: postcomments: false--- 2. 内容为多图时，新增标签{\% gp n-n \%}(content){\% endgp \%}。具体如下： 1234&#123;% gp 2-2 %&#125;![](http://octodex.github.com/images/minion.png)![](http://octodex.github.com/images/minion.png)&#123;% endgp %&#125; 然并卵… 前方高能 大坑三居然报错了，为什么会报错，我的内心是拒绝的… 还好我没放弃！！！ 找到{\% gp \%}标签代码：/theme/next/source/script/tags/group-pictures.js 经过多次测试，发现代码错误，修改如下(43-63行)：123456789101112131415161718192021/*** 2-2** □ □ // 此为n-n设值所展示的排列方式，作为设值参考。默认：一行3列，依次排列** @param pictures*/group2Layout2: function (pictures) &#123; return this.getHTML([pictures]); // 将pictures变成二维数组作为实参&#125;,/*** 3-1** □ □ □** @param pictures*/group3Layout1: function (pictures) &#123; return this.getHTML([pictures]); // 将pictures变成二维数组作为实参&#125;, 特别说明：其实只有2-2，3-1的组合会报错，只有两个方法传了一维数组，导致后续报错。 好了，现在不报错了。启动起来，果然可以展示一行两列的图组了。 然并卵… 前方高能怎么不能点击放大？！ 我的内心是崩溃的，但是我没有放弃！！！ 通过与非gp标签图片对比，我发现gp标签渲染时，并没有给图片加&lt;a/&gt;标签，导致fancybox插件并未运行起来。 OK，找到原因了。定位代码: 在/theme/next/source/script/tags/group-pictures.js（824行getColumnHtml方法），做如下修改：1234567891011121314151617181920212223getColumnHTML: function (pictures) &#123; var columns = []; var columnWidth = 100 / pictures.length; var columnStyle = &apos; style=&quot;width: &apos; + columnWidth + &apos;%;&quot;&apos;; for (var i = 0; i &lt; pictures.length; i++) &#123; // 在&lt;img /&gt;元素上加一个父层&lt;a/&gt;,结构如下： // &lt;div class=&quot;group-picture-column&quot; &gt; // &lt;a href=&quot;&quot; class=&quot;fancybox fancybox.image&quot; rel=&quot;group&quot;&gt; // &lt;img /&gt; // &lt;/a&gt; // &lt;/div&gt; var src = pictures[i].match(/src=&quot;[^&quot;]*&quot;/)[0].replace(/(src=)|&quot;/g,&quot;&quot;); var html = &apos;&lt;div class=&quot;group-picture-column&quot; &apos; + columnStyle + &apos;&gt;&apos; + &apos;&lt;a href=&quot;&apos;+ src +&apos;&quot; class=&quot;fancybox fancybox.image&quot; rel=&quot;group&quot;&gt;&apos; + pictures[i] + &apos;&lt;/a&gt;&lt;/div&gt;&apos; columns.push(html); &#125; return columns.join(&apos;&apos;); &#125;&#125;; 这回终于解决了。效果请参考我的图册。 填坑完结。希望我踩过的坑，对大家有所帮助。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
        <tag>github</tag>
        <tag>填坑记</tag>
      </tags>
  </entry>
</search>