<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Terra&#39;s</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://terrahuang.github.io/"/>
  <updated>2017-08-29T17:19:00.171Z</updated>
  <id>https://terrahuang.github.io/</id>
  
  <author>
    <name>Terra</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器HTTP缓存机制</title>
    <link href="https://terrahuang.github.io/2017/08/29/http-cache/"/>
    <id>https://terrahuang.github.io/2017/08/29/http-cache/</id>
    <published>2017-08-29T09:09:39.023Z</published>
    <updated>2017-08-29T17:19:00.171Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器HTTP缓存机制主要有两种 <code>强缓存</code>（Pragma/Expires/Cache-Control）和 <code>缓存协商</code>（Last-Modified/ETag）。</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>所谓强缓存，就是优先命中浏览器的缓存资源，当缓存不符合条件或不存在时，再向服务器发起请求。<br><a id="more"></a></p>
<ul>
<li><code>http 1.0</code> 协议版本中通过头部字段Pragma/Expires来标识</li>
<li><code>http 1.1</code> 协议中新增了字段Cache-Control定义缓存过期时间</li>
</ul>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma" target="_blank" rel="external">Pragma</a></h3><p>Pragma是通用首部字段，设置 <code>Pragma:no-cache</code> 用于禁用缓存。</p>
<p>1.客户端设置如下, 目前只有IE可识别，且不一定会加到请求报文。只对当前页面有效，对页面资源无效<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>2.若响应报文包含Pragma字段，浏览器会对资源标记，后续刷新页面不会命中缓存，而是直接发送请求。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires" target="_blank" rel="external">Expires</a></h3><p>Expires是实体首部字段，设置 <code>Expires:[GMT时间值]</code> 用于知会浏览器资源缓存过期时间</p>
<p>1.客户端设置如下，目前只有IE可识别，且不会加到请求报文。只对当前页面有效，对页面资源无效。如果希望不缓存页面，那么可以把content设为-1或0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;expires&quot; content=&quot;mon, 18 apr 2016 14:30:00 GMT&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>2.若响应报文包含Expires，字段值返回的是服务端时间。若服务端与客户端时间不同步，这个过期时间就会不准确，导致出错。</p>
<p><strong>如果Expires和Pramga同时出现在报文中，Pragma的优先级更高</strong></p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="external">Cache-Control</a></h3><p>Cache-Control是通用首部字段，设置 <code>Cache-Control:[cache-directive]</code> 指令来实现缓存机制。缓存指令是单向的，在响应里设置的指令，在请求中不用包含相同的指令。[cache-directive]有多个可选值，还可以组合使用，且在请求报文和响应报文定义不同，我列出了常见的几种，其它参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="external">MDN文档</a> </p>
<table>
<thead>
<tr>
<th>请求报文可选值</th>
<th>说明</th>
<th>响应报文可选值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-cache</td>
<td>不使用缓存，要求向原服务器发起请求</td>
<td>public</td>
<td>任何情况都得缓存资源</td>
</tr>
<tr>
<td>no-store</td>
<td>不保存到缓存或临时文件</td>
<td>Private[=field-name]</td>
<td>仅开放给某些用户作缓存,不能做共享缓存</td>
</tr>
<tr>
<td>max-age=seconds</td>
<td>告知服务器客户端可接收Age不大于seconds秒的资源</td>
<td>no-cache</td>
<td>不使用缓存，要求向服务器发起</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>告知服务器客户端希望优先获取缓存</td>
<td>no-store</td>
<td>不保存到缓存或临时文件</td>
</tr>
<tr>
<td>max-stale[=seconds]</td>
<td>告知服务器可接收超过缓存时间的资源</td>
<td>max-age=seconds</td>
<td>告知客户端在seconds秒内，资源不需要再次请求</td>
</tr>
<tr>
<td>no-transform</td>
<td>告知服务器客户端希望实体数据没有被转换</td>
<td>must-revalidate</td>
<td>当前资源一定向服务端发去请求验证的，失败返回504</td>
</tr>
</tbody>
</table>
<p><em>示例</em></p>
<blockquote>
<p>1.关闭缓存<br>Cache-Control: no-cache, no-store, must-revalidate<br>2.缓存静态资源<br>Cache-Control:public, max-age=31536000</p>
</blockquote>
<h2 id="缓存协商"><a href="#缓存协商" class="headerlink" title="缓存协商"></a>缓存协商</h2><p>当浏览器缓存过期，向服务器重新发送请求，若服务器资源并未更新时，直接返回304知会客户端使用缓存资源；否则返回更新资源。响应报文通过Last-Modified和ETag来判断缓存资源是否更新。这些做可以提高缓存复用率，加快页面渲染速度。</p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" target="_blank" rel="external">Last-Modified</a></h3><p>Last-Modified是资源在服务器上的最后修改时间，设置格式 <code>Last-Modified: [GMT时间]</code></p>
<ul>
<li>客户端第一次发起请求 -&gt; 服务端</li>
<li>服务端返回数据 [ <em>加上Last-Modified信息</em> ] -&gt; 客户端 -&gt; 客户端标记资源</li>
<li>客户端第二次请求 [ <em>报文加上标记字段</em> ] -&gt; 服务端</li>
<li>服务端 [ <em>比较修改时间，若一致，直接返回304和响应报头；否则，读取更新资源并返回</em> ] -&gt; 客户端</li>
</ul>
<blockquote>
<p>第二次请求报文附加字段有两个：<br>If-Modified-Since: <em>Last-Modified-value</em>  该值与服务端一致，返回304 （浏览器以此字段为准）<br>If-Unmodified-Since:<em>Last-Modified-value</em> 该值与服务端不一致，返回412</p>
</blockquote>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag" target="_blank" rel="external">ETag</a></h3><p>ETag是服务器资源生成的唯一标识，设置格式 <code>ETag:[字符串，如md5,guid]</code></p>
<ul>
<li>客户端第一次发起请求 -&gt; 服务端</li>
<li>服务端返回数据 [ <em>加上唯一标识，若是分布式，须保证生成唯一标识的算法一致</em> ] -&gt; 客户端 -&gt; 客户端标记ETag</li>
<li>客户端第二次请求 [ <em>报文加上标记字段</em> ] -&gt; 服务端</li>
<li>服务端 [ <em>比较唯一标识，若一致，直接返回304和响应报头；否则，读取更新资源并返回</em> ] -&gt; 客户端</li>
</ul>
<blockquote>
<p>第二次请求报文附加字段有两个：<br>If-None-Match: <em>ETag-value</em>  匹配上ETag，直接回送304  （浏览器以此字段为准）<br>If-Match: <em>ETag-value</em>      没有匹配上ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412</p>
</blockquote>
<p><strong>当If-None-Match与If-Modified-Since一同使用，If-None-Match优先级更高</strong><br><strong>Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，否则返回更新资源和200</strong></p>
<h2 id="实际应用技巧"><a href="#实际应用技巧" class="headerlink" title="实际应用技巧"></a>实际应用技巧</h2><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>1.网上有种说法，地址栏输入URL，F5/Ctrl+R(刷新按钮)用自动加上“Cache-Control:max-age=0”，不会命中强缓存，直接发起请求。<br>  另外还有一个说法， 不打开DevTool会直接向服务端发起请求，打开则会命中缓存。<br>  这两种说法都是错的。 以上两种情况都会先命中浏览器缓存，我用Chrome60反复测试了。</p>
<p>2.Chrome从缓存中读取数据，返回的是<code>200 ok from disk cache</code> \ <code>200 ok from memory cache</code>。from memory cache会比from disk cache读取速度更快，两种形式应该是表明缓存读取的方式不同</p>
<p>3.在DevTool-&gt;network-&gt;勾选<code>disable cahce</code> 或者 <code>shift+F5</code>，都会请求最新内容(304协商缓存、强缓存都无效)</p>
<ul>
<li>不会检查本地是否有缓存。</li>
<li>请求头信息(request header)不添加If-Modified-Since和If-None-Match字段</li>
</ul>
<p>4.查看所有的cache文件可在浏览器输入 chrome://view-http-cache/</p>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>1.静态资源部分，特别是图片资源，需设定一个较长的缓存时间，最好是可以在资源链接上加参数 <code>max-age</code> :</p>
<blockquote>
<p><a href="http://xxxxx/logo.png?max_age=2592000" target="_blank" rel="external">http://xxxxx/logo.png?max_age=2592000</a></p>
</blockquote>
<p>2.服务端在近期修改了该文件的话，因为强缓存客户端将无法获得最新，可将静态资源文件名或参数带上一串md5或时间标记符:</p>
<blockquote>
<p><a href="https://xxxxxxx/xxxxx.js?e23800c454aa573c0ccb16b52665ac26" target="_blank" rel="external">https://xxxxxxx/xxxxx.js?e23800c454aa573c0ccb16b52665ac26</a><br><a href="http://xxxxxx/xxxxx_94e7ca2.js" target="_blank" rel="external">http://xxxxxx/xxxxx_94e7ca2.js</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器HTTP缓存机制主要有两种 &lt;code&gt;强缓存&lt;/code&gt;（Pragma/Expires/Cache-Control）和 &lt;code&gt;缓存协商&lt;/code&gt;（Last-Modified/ETag）。&lt;/p&gt;
&lt;h2 id=&quot;强缓存&quot;&gt;&lt;a href=&quot;#强缓存&quot; class=&quot;headerlink&quot; title=&quot;强缓存&quot;&gt;&lt;/a&gt;强缓存&lt;/h2&gt;&lt;p&gt;所谓强缓存，就是优先命中浏览器的缓存资源，当缓存不符合条件或不存在时，再向服务器发起请求。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://terrahuang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="cache" scheme="https://terrahuang.github.io/tags/cache/"/>
    
      <category term="http" scheme="https://terrahuang.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>JS练习题</title>
    <link href="https://terrahuang.github.io/2017/08/22/exercise/"/>
    <id>https://terrahuang.github.io/2017/08/22/exercise/</id>
    <published>2017-08-22T11:32:51.733Z</published>
    <updated>2017-08-22T12:40:18.762Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一些JS练习题和参考代码，请看下文。</p>
<p><strong>1. 补全parseParm()，使其输出如下结果：</strong><br>{<br>   user: ‘anonymous’,<br>   id: [123, 456],  // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型<br>   city: ‘北京’,    // 中文<br>   enabled: true,  // 未指定值的 key 约定值为 true<br>}<br>url = ‘<a href="http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;\" target="_blank" rel="external">http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;\</a><br>      city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled’;<br>parseParam(url);<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function parseParam(url) &#123;</div><div class="line">  var params = &#123;&#125;;</div><div class="line">  var urlArr = (url || &quot;&quot;).split(&quot;?&quot;);</div><div class="line"></div><div class="line">  if (urlArr.length &lt; 2 || (!urlArr[1])) &#123;</div><div class="line">    return params;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var paramArr = urlArr[1].split(&quot;&amp;&quot;);</div><div class="line">  for (var i = 0; i &lt; paramArr.length; i++) &#123;</div><div class="line">    var pairArr = paramArr[i].split(&apos;=&apos;);</div><div class="line">    var key = pairArr[0];</div><div class="line">    var value = pairArr.length &gt; 1 ? decodeURI(pairArr[1]) : key == &quot;enabled&quot; ? true : &quot;&quot;;</div><div class="line"></div><div class="line">    if (params[key] == undefined) &#123;</div><div class="line">      params[key] = value;</div><div class="line">    &#125; else &#123;</div><div class="line">      params[key] = [params[key]];</div><div class="line">      params[key].push(value);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return params;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2. 实现一个最简单的模板引擎:</strong><br>render(‘我是[[name]], 年龄[[age]], 性别[[sex]]’,{<br>    name:’姓名’,<br>    age:18<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 如果?紧跟在任何量词 * + ? 或 &#123;&#125; 的后面，将会使量词变为非贪婪的（匹配尽量少的字符）</div><div class="line">// 和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。</div><div class="line">function render(tpl, data) &#123;</div><div class="line">  return tpl.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g, function (m, m1) &#123;</div><div class="line">    return data[m1];</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3. 将一个任意长的数字变成逗号分割的格式</strong><br>    // 1234.56 =&gt; “1,234.56” , 123456789 =&gt; “123,456,789”<br>  parseToMoney(1234.56) // return “1,234.56”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function parseToMoney(num) &#123;</div><div class="line">  num = num || &quot;&quot;;</div><div class="line">  var arr = num.toString().split(&quot;.&quot;);</div><div class="line">  var money = arr[0].replace(/(\d+?)(?=(\d&#123;3&#125;)+$)/g, &quot;$1,&quot;);</div><div class="line"></div><div class="line">  if (arr.length &gt; 1) &#123;</div><div class="line">    money += &quot;.&quot; + arr[1];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return money;</div><div class="line">&#125;</div><div class="line"></div><div class="line">parseToMoney(1234567891.34567)</div></pre></td></tr></table></figure>
<p><strong>4. 有一个全局变量 a，有一个全局函数 b，实现一个方法bindData，执行后，a的任何赋值都会触发b的执行</strong><br>var a = {x:1};<br>function b(){<br>  console.log(‘a的值发生改变’);<br>}<br>bindData();<br>a.x = 2; // 此时输出 a的值发生改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var a = &#123; x: 1, y: 2 &#125;;</div><div class="line">function b(key) &#123;</div><div class="line">  console.log(key + &apos;的值发生改变&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">bindData(a, b);</div><div class="line"></div><div class="line">function bindData(target, event) &#123;</div><div class="line">  for (var key in target) &#123;</div><div class="line">    if (target.hasOwnProperty(key)) &#123;</div><div class="line">      (function (_target, _key) &#123;</div><div class="line">        var v = _target[_key];</div><div class="line">        Object.defineProperty(_target, _key, &#123;</div><div class="line">          get: function () &#123;</div><div class="line">            return v;</div><div class="line">          &#125;,</div><div class="line">          set: function (_value) &#123;</div><div class="line">            if (v != _value) &#123;</div><div class="line">              event.call(this, _key)</div><div class="line">            &#125;</div><div class="line">            v = _value;</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">      &#125;)(target, key);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.x = 1;</div></pre></td></tr></table></figure>
<p><strong>5. 实现一个类，当从某个数字递增或者递减到另外一个数字，并且不管数字如何变化，都可以在指定的时间内完成</strong><br>var AnimateToNum = require(“animate-num”);<br>var numAnim = new AnimateToNum({<br>  animTime:2000,    // 每次数字变动持续的时间（ms），<br>  initNum:500,      // 初始化的数字<br>  onChange:function(num){<br>  console.log(num);<br>});<br>numAnim.toNum(100); // 从500变化到100，用2000ms的时间，在onChange回调中会一直从500倒数到100</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function AnimateToNum(options) &#123;</div><div class="line">  options = options || &#123;&#125;;</div><div class="line">  this.animTime = options.animTime || 0;</div><div class="line">  this.initNum = options.initNum || 0;</div><div class="line">  this.onChange = options.onChange || function (num) &#123; &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">AnimateToNum.prototype.toNum = function (finalNum) &#123;</div><div class="line">  if (finalNum &gt; this.initNum) &#123;</div><div class="line">    console.log(&quot;参数值不能大于初始值&quot;);</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (this.animTime &lt;= 0) &#123;</div><div class="line">    console.log(&quot;设置的animTime必须大于0&quot;);</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var that = this;</div><div class="line">  var temp = that.initNum</div><div class="line"></div><div class="line">  setInterval(function () &#123;</div><div class="line">    if (temp &gt; finalNum) &#123;</div><div class="line">      temp--;</div><div class="line">      that.onChange(temp);</div><div class="line">    &#125;</div><div class="line">  &#125;, that.animTime);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6. 现提供几个读取文件的方法，不借助全局变量实现一个函数，函数可以执行一次后返回一个目录下所有文件中是js后缀的文件列表</strong><br>var readdirSync = function(dir_path){ return [filename] } // 读取一个文件夹下的所有文件夹和文件的路径列表（Array）<br>var isDirectory = function(path) { return true/false; }   // 判断一个路径是否是文件夹<br>var existsSync = function(path){ return true/false;}      // 判断一个文件/文件夹是否存在<br>var getJSFiles = function(path) {}<br>getJSFiles(‘/code/‘); // return 一个文件列表的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var getJSFiles = function (path) &#123;</div><div class="line">  var result = [];</div><div class="line">  if (existsSync(path)) &#123;</div><div class="line">    if (isDirectory(path)) &#123;</div><div class="line">      readdirSync(path).forEach(function (file) &#123;</div><div class="line">        result = result.concat(getJSFiles(file))</div><div class="line">      &#125;);</div><div class="line">    &#125; else if (/\.js$/.test(path)) &#123;</div><div class="line">      result.push(path);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>7. 请封装一个 CustomFetch 方法，利用原生的 fetch api，但是实现以下几个需求：</strong><br>所有请求默认带上一个 token，值是 xxx<br>请求返回的时候，内部解析内容，并且判断 success 字段是否是 true，<br>如果不是，在 catch 中可以拿到一个Error，message 和 code 是接口返回的对应的内容<br>CustomFetch(“<a href="http://api.com/api&quot;).then((data)=&gt;{" target="_blank" rel="external">http://api.com/api&quot;).then((data)=&gt;{</a><br>  console.log(data); // 如果后台返回 true<br>}).catch((e)=&gt;{<br>  console.log(e.message); // 输出 “查询错误”<br>});<br>// 接口的返回模式<br>{<br>  success: false,<br>  code: ‘QUERY_ERROR’,<br>  data: {},<br>  message: ‘查询错误’<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">// 定义一个扩展错误类</div><div class="line">function FetchError(code, message) &#123;</div><div class="line">  this.code = code;</div><div class="line">  this.message = message;</div><div class="line">  this.name = &quot;FetchError&quot;;</div><div class="line">  this.stack = (new Error()).stack;</div><div class="line">&#125;</div><div class="line"></div><div class="line">FetchError.prototype = Object.create(Error.prototype);</div><div class="line">FetchError.prototype.constructor = FetchError;</div><div class="line"></div><div class="line">// 自定义fetch方法</div><div class="line">function CustomFetch(url) &#123;</div><div class="line">  var myHeaders = new Headers();</div><div class="line">  myHeaders.append(&quot;token&quot;, &quot;xxx&quot;);</div><div class="line">  myHeaders.append(&quot;Content-Type&quot;, &quot;application/json&quot;);</div><div class="line"></div><div class="line">  return fetch(url, &#123;</div><div class="line">    method: &apos;GET&apos;,</div><div class="line">    headers: myHeaders,</div><div class="line">    mode: &apos;cors&apos;,</div><div class="line">    cache: &apos;default&apos;</div><div class="line">  &#125;).then(function (response) &#123;</div><div class="line">    if (response.ok) &#123;</div><div class="line">      var res = response.json();</div><div class="line">      if (res.success) &#123;</div><div class="line">        return res.data;</div><div class="line">      &#125; else &#123;</div><div class="line">        //throw &#123; code: res.code, message: res.message &#125;;</div><div class="line">        throw new FetchError(res.code, res.message);</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      //throw &#123; code: response.status, message: response.statusText &#125;;</div><div class="line">      throw new FetchError(response.status, response.statusText)</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义一个基于Promise的Ajax数据请求方法</div><div class="line">function getJSON(url, method, data, isAsync) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">    var xmlHttp = new XMLHttpRequest();</div><div class="line">    xmlHttp.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class="line">    xmlHttp.responseType = &apos;json&apos;;</div><div class="line">    xmlHttp.onreadystatechange = handler;</div><div class="line">    xmlHttp.open(method || &quot;GET&quot;, url, isAsync == undefined ? true : isAsync);</div><div class="line">    xmlHttp.send(data);</div><div class="line"></div><div class="line">    function handler() &#123;</div><div class="line">      if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status === 200) &#123;</div><div class="line">        resolve(xmlHttp.response);</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(new Error(xmlHttp.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用示例</div><div class="line">getJSON(&quot;&quot;).then(function (response) &#123;</div><div class="line">  // success</div><div class="line">&#125;).then(function (error) &#123;</div><div class="line">  // fail</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>8. 算法题，实现一个函数，可以判断 a 字符串是否被包含在 b 字符串中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">// 时间复杂度较高的算法</div><div class="line">function isSubString(a, b) &#123;</div><div class="line">  if (!a || !b) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for (var i = 0; i &lt; b.length; i++) &#123;</div><div class="line">    var t = i;</div><div class="line">    for (var j = 0; j &lt; a.length; j++) &#123;</div><div class="line">      if (a[j] !== b[t++]) &#123;</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (j == a.length) &#123;</div><div class="line">      return true;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isSubString(&quot;abc&quot;, &quot;123abder&quot;);</div><div class="line"></div><div class="line">// KMP算法</div><div class="line">function isSubstrByKMP(a, b, m) &#123;</div><div class="line">  if (!a || !b) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var i = 0, j = 0;</div><div class="line">  while (i &lt; b.length &amp;&amp; j &lt; a.length) &#123;</div><div class="line">    if (a[j] == b[i]) &#123;</div><div class="line">      j++;</div><div class="line">      i++;</div><div class="line">    &#125; else &#123;</div><div class="line">      if (j == 0) &#123;</div><div class="line">        i++;</div><div class="line">      &#125; else &#123;</div><div class="line">        j = m[j - 1];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (j == a.length) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isSubstrByKMP(&quot;abcdabd&quot;, &quot;bbcabcdababcdabcdabde&quot;, [0, 0, 0, 0, 1, 2, 0])</div></pre></td></tr></table></figure>
<p><strong>9. 下面五段代码分别输出什么？并且什么时候输出什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">  console.log(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// result: 0,1,2,3,4</div><div class="line"></div><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">  setTimeout(function () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;, 1000 * i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// result: 5,5,5,5,5</div><div class="line"></div><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">  (function (i) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">      console.log(i);</div><div class="line">    &#125;, i * 1000);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// result: 0,1,2,3,4</div><div class="line"></div><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">  (function () &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">      console.log(i);</div><div class="line">    &#125;, i * 1000);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// result: 5,5,5,5,5</div><div class="line"></div><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">  setTimeout((function (i) &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;)(i), i * 1000);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// result: 0,1,2,3,4</div></pre></td></tr></table></figure>
<p><strong>10. 将数字转换成中文大写的表示，处理到万级别，例如 12345 =&gt; 一万二千三百四十五</strong><br>function toLowerNum(){}<br>console.log(toLowerNum(12345)); // 输出 一万二千三百四十五<br>console.log(toLowerNum(10001)); // 输出 一万零一<br>console.log(toLowerNum(10011)); // 输出 一万零十一<br>console.log(toLowerNum(10000)); // 输出 一万</p>
<p>(未完待续)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一些JS练习题和参考代码，请看下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 补全parseParm()，使其输出如下结果：&lt;/strong&gt;&lt;br&gt;{&lt;br&gt;   user: ‘anonymous’,&lt;br&gt;   id: [123, 456],  // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型&lt;br&gt;   city: ‘北京’,    // 中文&lt;br&gt;   enabled: true,  // 未指定值的 key 约定值为 true&lt;br&gt;}&lt;br&gt;url = ‘&lt;a href=&quot;http://www.domain.com/?user=anonymous&amp;amp;id=123&amp;amp;id=456&amp;amp;\&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.domain.com/?user=anonymous&amp;amp;id=123&amp;amp;id=456&amp;amp;\&lt;/a&gt;&lt;br&gt;      city=%E5%8C%97%E4%BA%AC&amp;amp;d&amp;amp;enabled’;&lt;br&gt;parseParam(url);&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://terrahuang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://terrahuang.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GithubPages+nexT站点搭建</title>
    <link href="https://terrahuang.github.io/2017/07/27/hexo-github-nexT/"/>
    <id>https://terrahuang.github.io/2017/07/27/hexo-github-nexT/</id>
    <published>2017-07-27T07:11:06.000Z</published>
    <updated>2017-08-29T10:21:56.250Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning"><p><strong>写在前面</strong><br>    趁离职期间想整理下这些年积累的东西，决定自己建个站点，为了方便简单选择了Hexo+GitHub Pages。但是做后端开发久了，真心觉得静态站点有点费事。考虑到github免费，那先将就吧，以后还是得自己搞个服务器。这篇先来讲讲搭建时遇到的坑，下一篇讲讲我对Hexo的理解。</p>
</div>
<h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>关于Hexo安装操作网上有很多，建议直接参考<a href="https://hexo.io/zh-cn/" title="Hexo官网" target="_blank" rel="external">Hexo官网</a>。我贴下几条关键指令：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 安装Hexo环境</div><div class="line">npm install hexo-cli -g</div><div class="line"></div><div class="line">// 初始化blog站点</div><div class="line">hexo init blog</div><div class="line">cd blog</div><div class="line">npm install</div><div class="line"></div><div class="line">// 生成静态文件</div><div class="line">hexo g</div><div class="line"></div><div class="line">// 在本地启动站点，指定端口，请加-p [端口]</div><div class="line">hexo server</div><div class="line">hexo server -p 5000</div><div class="line"></div><div class="line">// 发布</div><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<h2 id="利用Github-Pages部署站点"><a href="#利用Github-Pages部署站点" class="headerlink" title="利用Github Pages部署站点"></a>利用Github Pages部署站点</h2><p>由于Hexo生成的静态文件，恰好github支持静态文件渲染，github就成了个人博客最好的免费服务器。我在网上查到很多部署方面的文章，基本都是如下说法：</p>
<p><strong>1. 在_config.yml配置deploy参数，前提先安装hexo-deployer-git插件：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/TerraHuang/terrahuang.github.io.git</div><div class="line">  branch:   // 分支这个地方很关键呀，被坑了...</div></pre></td></tr></table></figure></p>
<p><strong>2. 在github上创建新的repository，且以<code>[账号名].github.io</code>命名。将该项目克隆到本地。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/TerraHuang/terrahuang.github.io.git</div></pre></td></tr></table></figure></p>
<p>   以上步骤都没错，非常正确，不过坑马上就来了。<code>前方高能</code></p>
<h3 id="大坑一"><a href="#大坑一" class="headerlink" title="大坑一"></a>大坑一</h3><p><strong>3. 将hexo生成站点的代码发布到master分支，将部署的静态文件代码发布到gh-pages分支，然后在github项目Settings中将Source改为gh-pages。我照做如下：</strong></p>
<p><img src="/screenshot/20170728/git-page-setting.png" alt=""></p>
<p>虽然我的内心很崩溃，但是我还没放弃！！！</p>
<p>还好Source旁边有个<code>Learn more</code>，用户体验做的不错，点个赞。</p>
<p>点开它，才发现别有洞天呀，网上文章真不能全信~~</p>
<p><img src="/screenshot/20170728/learn-more.png" alt=""></p>
<div class="note primary"><p>哦，原来[账号名].github.io这种命名只能使用master分支作为站点资源。</p>
</div>
<p>另外Github pages还支持其它几种方式，如下：</p>
<p><img src="/screenshot/20170728/page-source.png" alt=""></p>
<p><strong>4. 正确的Github Pages发布方式:</strong></p>
<ul>
<li>静态站点部署文件应放到master分支</li>
<li>Hexo生成代码放到其它分支，或者新建其它的repository来托管</li>
<li><p>_config.yml的deploy-&gt;branch须写成<code>master</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: ...</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
</li>
<li><p>在浏览器中请求 <a href="https://[账号名].github.io" target="_blank" rel="external">https://[账号名].github.io</a> 即为个人站点。</p>
</li>
</ul>
<p><strong>5. Github Pages绑定域名：</strong></p>
<ul>
<li>在阿里云万网上购买域名</li>
<li>在master分支新建CNAME文件，名称必须全大写，内容为需绑定的域名<br><img src="/screenshot/20170728/dns.png" alt=""></li>
<li>在万网域名管理页面新增一条解析，如下：<br><img src="/screenshot/20170728/dns-express.png" alt=""></li>
</ul>
<p>具体步骤说明，请参考<strong>yuan3065的博客</strong>：<a href="http://blog.csdn.net/yuan3065/article/details/51594454" target="_blank" rel="external">GitHub Pages 绑定来自阿里云的域名</a></p>
<h2 id="nexT主题及改造"><a href="#nexT主题及改造" class="headerlink" title="nexT主题及改造"></a>nexT主题及改造</h2><p>毕竟是自己的第一个站点，选用主题也是很谨慎的，在众多炫目的主题中选择了nexT。据说目前是得星最多的一套主题。我看中它的点如下：<br><div class="note primary"><p><strong>优势：</strong> 样式简洁，文档详细，提供的第三方服务丰富，改造容易</p>
</div></p>
<h3 id="主题色"><a href="#主题色" class="headerlink" title="主题色"></a>主题色</h3><p>原来的黑色太暗沉，像我心里这么阳光的人，果断换了个明亮的调调。但是nexT并没有提供主题色的更改配置，我用的是笨办法，直接在<code>theme/next/source/css/</code>中修改色值。以后有时间再修改下代码，提取到_config.yml配置中来。</p>
<h3 id="新增第三方服务"><a href="#新增第三方服务" class="headerlink" title="新增第三方服务"></a>新增第三方服务</h3><p>配置第三方服务比较简单，请参考<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">nexT文档</a></p>
<p>新增功能如下：</p>
<ul>
<li><strong>站内搜索：插件hexo-generator-searchdb</strong></li>
<li><strong>文章阅读次数统计：LeanCloud</strong></li>
<li><strong>内容分享：Jiathis</strong></li>
<li><strong>评论系统：disqus（不翻墙无法显示，考虑代理）</strong><h3 id="大坑二"><a href="#大坑二" class="headerlink" title="大坑二"></a>大坑二</h3><div class="note primary"><p>特别提醒：注册disqus时，一定要翻墙。如果是利用hosts文件翻墙，请在hosts新增一条[sitename].disqus.com-&gt;xx.xx.xx.xx域名映射，IP地址与disqus.com相同即可。</p>
</div>
</li>
</ul>
<h3 id="多图显示"><a href="#多图显示" class="headerlink" title="多图显示"></a>多图显示</h3><p>为了展示图册效果，尝试显示多图，在网上找到方法如下：</p>
<p><strong>1. 在站点/source下新增pictures/index.md文件。Front-matter如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: &quot;图册&quot;</div><div class="line">type: &quot;picture&quot;  //type必须为&apos;picture&apos;</div><div class="line">layout: post</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p><strong>2. 内容为多图时，新增标签<code>{\% gp n-n \%}(content){\% endgp \%}</code>。具体如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;% gp 2-2 %&#125;</div><div class="line">![](http://octodex.github.com/images/minion.png)</div><div class="line">![](http://octodex.github.com/images/minion.png)</div><div class="line">&#123;% endgp %&#125;</div></pre></td></tr></table></figure>
<p>然并卵…    <code>前方高能</code></p>
<h3 id="大坑三"><a href="#大坑三" class="headerlink" title="大坑三"></a>大坑三</h3><p>居然报错了，为什么会报错，我的内心是拒绝的… 还好我没放弃！！！</p>
<p>找到<code>{\% gp \%}</code>标签代码：<code>/theme/next/source/script/tags/group-pictures.js</code></p>
<p>经过多次测试，发现代码错误，修改如下(43-63行)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 2-2</div><div class="line">*</div><div class="line">* □ □  // 此为n-n设值所展示的排列方式，作为设值参考。默认：一行3列，依次排列</div><div class="line">*</div><div class="line">* @param pictures</div><div class="line">*/</div><div class="line">group2Layout2: function (pictures) &#123;</div><div class="line">  return this.getHTML([pictures]);  // 将pictures变成二维数组作为实参</div><div class="line">&#125;,</div><div class="line"></div><div class="line">/**</div><div class="line">* 3-1</div><div class="line">*</div><div class="line">* □ □ □</div><div class="line">*</div><div class="line">* @param pictures</div><div class="line">*/</div><div class="line">group3Layout1: function (pictures) &#123;</div><div class="line">  return this.getHTML([pictures]);  // 将pictures变成二维数组作为实参</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<div class="note primary"><p><strong>特别说明：</strong>其实只有2-2，3-1的组合会报错，只有两个方法传了一维数组，导致后续报错。</p>
</div>
<p>好了，现在不报错了。启动起来，果然可以展示一行两列的图组了。</p>
<p>然并卵…   <code>前方高能</code><br>怎么不能点击放大？！ 我的内心是崩溃的，但是我没有放弃！！！</p>
<p>通过与非<code>gp</code>标签图片对比，我发现<code>gp</code>标签渲染时，并没有给图片加<code>&lt;a/&gt;</code>标签，导致fancybox插件并未运行起来。</p>
<p>OK，找到原因了。定位代码: 在<code>/theme/next/source/script/tags/group-pictures.js</code>（824行<code>getColumnHtml</code>方法），做如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">getColumnHTML: function (pictures) &#123;</div><div class="line">    var columns = [];</div><div class="line">    var columnWidth = 100 / pictures.length;</div><div class="line">    var columnStyle = &apos; style=&quot;width: &apos; + columnWidth + &apos;%;&quot;&apos;;</div><div class="line"></div><div class="line">    for (var i = 0; i &lt; pictures.length; i++) &#123;</div><div class="line">    </div><div class="line">      // 在&lt;img /&gt;元素上加一个父层&lt;a/&gt;,结构如下：</div><div class="line">      // &lt;div class=&quot;group-picture-column&quot; &gt;</div><div class="line">      // &lt;a href=&quot;&quot; class=&quot;fancybox fancybox.image&quot; rel=&quot;group&quot;&gt;</div><div class="line">      //   &lt;img  /&gt;</div><div class="line">      // &lt;/a&gt;</div><div class="line">      // &lt;/div&gt;</div><div class="line">      var src = pictures[i].match(/src=&quot;[^&quot;]*&quot;/)[0].replace(/(src=)|&quot;/g,&quot;&quot;);</div><div class="line">      var html = &apos;&lt;div class=&quot;group-picture-column&quot; &apos; + columnStyle + &apos;&gt;&apos;</div><div class="line">          + &apos;&lt;a href=&quot;&apos;+ src +&apos;&quot; class=&quot;fancybox fancybox.image&quot; rel=&quot;group&quot;&gt;&apos;</div><div class="line">          + pictures[i] </div><div class="line">          + &apos;&lt;/a&gt;&lt;/div&gt;&apos;</div><div class="line">      columns.push(html);</div><div class="line">    &#125;</div><div class="line">    return columns.join(&apos;&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这回终于解决了。效果请参考我的<a href="/pictures">图册</a>。</p>
<p><strong>填坑完结。希望我踩过的坑，对大家有所帮助。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;br&gt;    趁离职期间想整理下这些年积累的东西，决定自己建个站点，为了方便简单选择了Hexo+GitHub Pages。但是做后端开发久了，真心觉得静态站点有点费事。考虑到github免费，那先将就吧，以后还是得自己搞个服务器。这篇先来讲讲搭建时遇到的坑，下一篇讲讲我对Hexo的理解。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;Hexo安装&quot;&gt;&lt;a href=&quot;#Hexo安装&quot; class=&quot;headerlink&quot; title=&quot;Hexo安装&quot;&gt;&lt;/a&gt;Hexo安装&lt;/h2&gt;&lt;p&gt;关于Hexo安装操作网上有很多，建议直接参考&lt;a href=&quot;https://hexo.io/zh-cn/&quot; title=&quot;Hexo官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo官网&lt;/a&gt;。我贴下几条关键指令：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://terrahuang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://terrahuang.github.io/tags/Hexo/"/>
    
      <category term="nexT" scheme="https://terrahuang.github.io/tags/nexT/"/>
    
      <category term="github" scheme="https://terrahuang.github.io/tags/github/"/>
    
      <category term="填坑记" scheme="https://terrahuang.github.io/tags/%E5%A1%AB%E5%9D%91%E8%AE%B0/"/>
    
  </entry>
  
</feed>
